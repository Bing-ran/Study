4.1.1 内存编址方法
	内存在逻辑上就是一个一个的格子，用来装东西（里面装的东西就是内存中存的数），每个格子有个编号（内存地址），这个内存地址（一个数字）和这个格子的空间（实质是一个空间）是一一对应且永久绑定的。这就是内存编址方法。

	在程序运行时，计算机中的CPU实际只认识内存地址，而不关心这个地址所代表的空间在哪里，怎么分布这些实体问题。因为硬件设计保证了按照这个地址就能找到这个格子，内存单元的两个概念：地址和其对应的空间是内存单元的两个方面。

4.1.2 关键：内存编址是以字节为单位的
	随便一个数字（例如7），这个数字是一个内存地址，这个地址对应的空间有多大？	一个字节（8bit）
	如果把内存比喻为一栋大楼，那么这个楼里面的一个一个房间就是一个一个内存格子，这个格子的大小就是固定的8bit，就好像这个大楼所有的房间户型是一样的。

4.1.3 内存和数据类型的关系
	c语言的基本数据类型：char short int long float double
	int 整形（整数类型，这个整形就体现在它和CPU本身的数据位宽是一样的）。例如：32位  整形就是32位
	数据类型和内存的关系在于：
		数据类型是用来定义变量的，而这些变量需要存储，运算在内存中。所以数据类型必须和内存相匹配才能获得最好的性能，或者可能不工作或者效率低下。

	在32位系统中定义变量最好用int，以为这样效率高。原因在于32位系统的本身配合内存也是32位的，这样的硬件配置天生适合定义32位的int类型变量，效率最高。也能定义8位的char类型变量或者16位的short类型变量，但实际上访问效率不高。
	在很多32位环境下，我们实际定义bool类型的变量（实际只需要1个bit就够了）都是用int来实现bool的。也就是说我们定义一个bool b1；时编译器实际上帮我们分配了32位的内存来存储这个bool变量b1，编译器这么做实际上浪费了31位的内存，但是好处是效率高。

	问题：实际编程时要以省内存为大还是要以运行效率为重？答案是不一定，看具体情况。很多年前内存很贵机器上内存都很少，那时候写代码以省内存为主，现在随着半导体技术的发展内存变得很便宜了，现在的机器都是高配的，不在乎省一点内存，而效率和用户天眼变成了关键。所以现在程序大部分都已效率为重。

4.1.4 内存对齐
	在c中 int a；定义一个int类型的变量，在内存中就必须分配4个字节来存储这个a。有两种不同的分配思路和策略；
	1 : 0 1 2 3								对齐访问
	2 : 1 2 3 4 或者 2 3 4 5 或者 3 4 5 6 	非对齐访问
	内存对齐不是逻辑问题，而是硬件问题。从硬件角度来说32位内存它 0 1 2 3 四个单元本身逻辑上就有相关性，这四个字节组合起来当做一个int硬件上就是合适的，效率高。

	对齐访问配合硬件，所以效率很高；非对齐访问因为和硬件本身不搭配，所以效率不高。（因为兼容性的问题，一般硬件也都提供非对齐访问，但效率低很多）。

4.1.5 从内存编址看数组的意义