1、哈佛结构和冯诺依曼结构
	哈佛结构：数据与代码分开的。
	冯诺依曼结构：数据与代码放在一起。
	代码：函数
	数据：全局变量、局部变量

	Linux系统中，运行程序时：这时候所有的应用程序的代码和数据都在DRAM中，所以这种结构式冯诺依曼结构；在单片机种，我们把代码烧写到Flash（NorFlash）中，然后程序在Flash中原地运行，程序中所涉及到的数据（全局变量、局部变量）不能放在Flash中，必须放在RAM（SRAM）中。这种就叫哈佛结构。

2、动态内存DRAM和静态内存SRAM
	分配时间不同：
		内存的静态分配发生在程序编译和链接时，而内存的动态分配发生下程序调入和执行时。
	
	分配空间不同：
		堆内存：动态分配，没有静态分配的堆。
		栈内存：可静态分配、可动态分配。
		静态分配：编译器完成。
		动态分配：通过malloc函数、new关键字等实现。
		
		注：栈的动态分配时被动的，如：当我们在堆上动态分配内存后往往需要一个左值来接受这块内存，这个左值的变量就是分配在栈空间的。
3、为什么需要内存
	内存是用来存储可变数据的，数据在程序中变现为全局变量、局部变量等（在gcc中，其实常量是存储在内存中的）（大部分单片机中，常量存储在flash中，也就是代码段）。对我们写程序来书非常重要，对程序运行更是本质相关。
	所以内存对程序来说几乎是本质需求。越简单的程序需要越少的内存，二越庞大越复杂的程序需要更多的内存。内存管理是我们写程序时最重要的话题。我们以前学过的了解过的很多编程关键其实都是为了内存，譬如说数据结构（数据结构是研究数据如何组织的，数据是放在内存中的）和算法（算法是为了用更优秀更有效的方法来加工数据，既然跟数据有关及离不开内存）。
	
4、深入思考：如何管理内存（无OS时，有OS时）
	对于计算机来说，内存容量越大可能性越大，所以大家都希望自己的内存更大。我们写程序时如何管理内存就成了很大的问题。如果管理不善，可能会造成程序运行小号过多的内存，这样迟早内存都被你这个程序吃光了，当没有内存可用是程序就会崩溃。所以内存对程序来说是一种资源,所以管理内存对程序来说是一个重要的技术和话题。
	
	先从操作系统角度讲：操作系统长官所有的硬件内存，因为内存很大，所以操作系统吧内存分成一个一个的页面（其实就是一块，一般是4KB），然后以页面为单位来管理。页面内用更细小的方式来以字节为单位管理。操作系统内存管理的原理非常麻烦、非常复杂、非常不人性化。那么对我们这些使用操作系统的人来说，其实不需要这些细节。操作系统给我们提供内存管理的一些接口，我么只需要用API即可管理内存。譬如在C语言中使用malloc free这些接口来管理内存。
	没有操作系统时：在没有操作系统（裸机）中，程序需要直接操作内存，编程者需要自己计算内粗弄得使用和安排。如果编程者不小心把内存用错了，错误结果需要自己承担。
	
	再从语言角度来讲：不同的语言提供了不同的操作内存的接口，譬如汇编：根本没有任何内存管理，内存管理全靠程序员自己，汇编操作内存直接使用内存地址（譬如：0xd0020010），非常麻烦；
	譬如C语言：c语言中编译器帮我们管理直接内存地址，我们都是通过编译器提供的变量名等来访问内存的，操作系统下如果需要大块内存，可以通过API（malloc free）来访问系统内存。裸机程序中需要大块的内存需要自己来定义数组等来解决
	
	譬如C++语言：c++语言对内存的使用进一步封装。我们可以用new来船舰对象（其实就是为对象分配内存），然后使用完了用delate来删除对象（释放内存）。所以c++对内存的管理比c要高级一些，容易一些。但是c++中内存的管理还是靠程序员自己来做。如果程序员new了一个对象，但是用完忘记delete就会造成这个对象占用的内存不能释放，这就是内存泄漏。
	
	Java/c#等语言：这些语言不直接操作内存，而是通过虚拟机来操作内存。这样虚拟机作为我们程序的代理，来帮我们处理内存的释放工作。如果我们申请了忘记释放，虚拟机会帮我们释放这些内存。但是其实虚拟机回收内存是要付出一档代价的，所以说语言没有好坏只有适应不适应。但我们程序对性能非常在乎时（操作系统内核）就会用c/c++语言；但我们对开发程序的速度非常在乎时就会用Java/C#等语言。
	
	
