1、哈佛结构和冯诺依曼结构
	哈佛结构：数据与代码分开的。
	冯诺依曼结构：数据与代码放在一起。
	代码：函数
	数据：全局变量、局部变量

	Linux系统中，运行程序时：这时候所有的应用程序的代码和数据都在DRAM中，所以这种结构式冯诺依曼结构；在单片机种，我们把代码烧写到Flash（NorFlash）中，然后程序在Flash中原地运行，程序中所涉及到的数据（全局变量、局部变量）不能放在Flash中，必须放在RAM（SRAM）中。这种就叫哈佛结构。

2、动态内存DRAM和静态内存SRAM
	分配时间不同：
		内存的静态分配发生在程序编译和链接时，而内存的动态分配发生下程序调入和执行时。
	
	分配空间不同：
		堆内存：动态分配，没有静态分配的堆。
		栈内存：可静态分配、可动态分配。
		静态分配：编译器完成。
		动态分配：通过malloc函数、new关键字等实现。
		
		注：栈的动态分配时被动的，如：当我们在堆上动态分配内存后往往需要一个左值来接受这块内存，这个左值的变量就是分配在栈空间的。
3、为什么需要内存
	内存是用来存储可变数据的，数据在程序中变现为全局变量、局部变量等（在gcc中，其实常量是存储在内存中的）（大部分单片机中，常量存储在flash中，也就是代码段）。对我们写程序来书非常重要，对程序运行更是本质相关。
	所以内存对程序来说几乎是本质需求。越简单的程序需要越少的内存，二越庞大越复杂的程序需要更多的内存。内存管理是我们写程序时最重要的话题。我们以前学过的了解过的很多编程关键其实都是为了内存，譬如说数据结构（数据结构是研究数据如何组织的，数据是放在内存中的）和算法（算法是为了用更优秀更有效的方法来加工数据，既然跟数据有关及离不开内存）。
	
4、深入思考：如何管理内存（无OS时，有OS时）
	对于计算机来说，内存容量越大可能性越大，所以大家都希望自己的内存更大。我们写程序时如何管理内存就成了很大的问题。如果管理不善，可能会造成程序运行小号过多的内存，这样迟早内存都被你这个程序吃光了，当没有内存可用是程序就会崩溃。所以内存对程序来说是一种资源,所以管理内存对程序来说是一个重要的技术和话题。
	
	先从操作系统角度讲：操作系统长官所有的硬件内存，因为内存很大，所以操作系统吧内存分成一个一个的页面（其实就是一块，一般是4KB），然后以页面为单位来管理。页面内用更细小的方式来以字节为单位管理。操作系统内存管理的原理非常麻烦、非常复杂、非常不人性化。那么对我们这些使用操作系统的人来说，其实不需要这些细节。操作系统给我们提供内存管理的一些接口，我么只需要用API即可管理内存。譬如在C语言中使用malloc free这些接口来管理内存。
	没有操作系统时：在没有操作系统（裸机）中，程序需要直接操作内存，编程者需要自己计算内粗弄得使用和安排。如果编程者不小心把内存用错了，错误结果需要自己承担。
	
	再从语言角度来讲：不同的语言提供了不同的操作内存的接口，譬如汇编：根本没有任何内存管理，内存管理全靠程序员自己，汇编操作内存直接使用内存地址（譬如：0xd0020010），非常麻烦；
	譬如C语言：c语言中编译器帮我们管理直接内存地址，我们都是通过编译器提供的变量名等来访问内存的，操作系统下如果需要大块内存，可以通过API（malloc free）来访问系统内存。裸机程序中需要大块的内存需要自己来定义数组等来解决
	
	譬如C++语言：c++语言对内存的使用进一步封装。我们可以用new来船舰对象（其实就是为对象分配内存），然后使用完了用delate来删除对象（释放内存）。所以c++对内存的管理比c要高级一些，容易一些。但是c++中内存的管理还是靠程序员自己来做。如果程序员new了一个对象，但是用完忘记delete就会造成这个对象占用的内存不能释放，这就是内存泄漏。
	
	Java/c#等语言：这些语言不直接操作内存，而是通过虚拟机来操作内存。这样虚拟机作为我们程序的代理，来帮我们处理内存的释放工作。如果我们申请了忘记释放，虚拟机会帮我们释放这些内存。但是其实虚拟机回收内存是要付出一档代价的，所以说语言没有好坏只有适应不适应。但我们程序对性能非常在乎时（操作系统内核）就会用c/c++语言；但我们对开发程序的速度非常在乎时就会用Java/C#等语言。
	
	
1、什么是内存？（硬件和逻辑连个角度）
	硬件：内存是电脑的一个配件，内存条。硬件实现原理：SRAM（静态内存，不需要初始化直接用） DRAM（动态内存、需要初始化再使用；DDR1....DDR2）
	逻辑：内存是可以随机访问（只要给一个地址就可以访问这个地址）、并且可以读写（逻辑上可以限制只读或只写）；内存再编程中天然用来存放变量的。（因为有了内存，所以c语言才能定义变量，C语言中的一个变量实际就对应内存中的一个单元）。
	
2、内存的逻辑抽象图（内存的编程模型）
	逻辑：内存实际上是由无限多个内存单元格组成，每个单元格有一个固定的地址叫内存地址。这个内存地址和这个内存单元格唯一对应且永久绑定，
	
	逻辑上来说，内存地址无限大，但是实际上内存时有限的，以32位操作系统（32位系统指的是32位数据线，但是一般地址线也是32位，这个地址线决定了内存的地址只能是32位二进制，所以逻辑上的大小为2的32次方）内存限制就是4G，实际上32位的系统的可用的内存一般是<=4G的（譬如32位CPU装32位windows，内存只有1G）
	
	
	
5、内存位宽（硬件和逻辑）
	硬件：硬件内存是先本身是有位宽的，也就是内存条是8位、16位（内存芯片间可以并联，8、16位可以实现32位）
	逻辑：内存位宽任意。（如24位，但是买不到没意义）


4.1.1 内存编址方法
	内存在逻辑上就是一个一个的格子，用来装东西（里面装的东西就是内存中存的数），每个格子有个编号（内存地址），这个内存地址（一个数字）和这个格子的空间（实质是一个空间）是一一对应且永久绑定的。这就是内存编址方法。

	在程序运行时，计算机中的CPU实际只认识内存地址，而不关心这个地址所代表的空间在哪里，怎么分布这些实体问题。因为硬件设计保证了按照这个地址就能找到这个格子，内存单元的两个概念：地址和其对应的空间是内存单元的两个方面。

4.1.2 关键：内存编址是以字节为单位的
	随便一个数字（例如7），这个数字是一个内存地址，这个地址对应的空间有多大？	一个字节（8bit）
	如果把内存比喻为一栋大楼，那么这个楼里面的一个一个房间就是一个一个内存格子，这个格子的大小就是固定的8bit，就好像这个大楼所有的房间户型是一样的。

4.1.3 内存和数据类型的关系
	c语言的基本数据类型：char short int long float double
	int 整形（整数类型，这个整形就体现在它和CPU本身的数据位宽是一样的）。例如：32位  整形就是32位
	数据类型和内存的关系在于：
		数据类型是用来定义变量的，而这些变量需要存储，运算在内存中。所以数据类型必须和内存相匹配才能获得最好的性能，或者可能不工作或者效率低下。

	在32位系统中定义变量最好用int，以为这样效率高。原因在于32位系统的本身配合内存也是32位的，这样的硬件配置天生适合定义32位的int类型变量，效率最高。也能定义8位的char类型变量或者16位的short类型变量，但实际上访问效率不高。
	在很多32位环境下，我们实际定义bool类型的变量（实际只需要1个bit就够了）都是用int来实现bool的。也就是说我们定义一个bool b1；时编译器实际上帮我们分配了32位的内存来存储这个bool变量b1，编译器这么做实际上浪费了31位的内存，但是好处是效率高。

	问题：实际编程时要以省内存为大还是要以运行效率为重？答案是不一定，看具体情况。很多年前内存很贵机器上内存都很少，那时候写代码以省内存为主，现在随着半导体技术的发展内存变得很便宜了，现在的机器都是高配的，不在乎省一点内存，而效率和用户天眼变成了关键。所以现在程序大部分都已效率为重。

4.1.4 内存对齐
	在c中 int a；定义一个int类型的变量，在内存中就必须分配4个字节来存储这个a。有两种不同的分配思路和策略；
	1 : 0 1 2 3								对齐访问
	2 : 1 2 3 4 或者 2 3 4 5 或者 3 4 5 6 	非对齐访问
	内存对齐不是逻辑问题，而是硬件问题。从硬件角度来说32位内存它 0 1 2 3 四个单元本身逻辑上就有相关性，这四个字节组合起来当做一个int硬件上就是合适的，效率高。

	对齐访问配合硬件，所以效率很高；非对齐访问因为和硬件本身不搭配，所以效率不高。（因为兼容性的问题，一般硬件也都提供非对齐访问，但效率低很多）。

4.1.5 从内存编址看数组的意义


4.1.5 C语言如何操作内存

1、C语言对内存地址的封装（用变量名来访问内存、数据类型的含义、函数名的含义）
	C语言中： int a; a = 5 ; a += 4; --> a == 9;
结合内存来解析C语言语句的本质：
	int a; //编译器帮我们申请了一个int类型的内存格子（4个字节，地址是确定的且只有编译器知道，我			们是不知道，也不需要知道），并且把符号a和这个格子绑定。
	a = 5; //编译器发现我们要给a赋值，就会把这个值5丢到a绑定的格子中去。
	a += 4;//编译器发现我们要给a加值，a += 4 等效 a = a + 4;编译器就会把a 							的值读出来，然后再 +4 ，最后将结果9 存到格子中。

数据类型：
	C语言中数据类型的本质含义是：表示一个内存格子的长度和解析方法。

	内存单元编址的单位是字节。
	(int *)0;		//	0是一个地址，其存的是一个指针，其指向int类型的数
	(float *)0;
	(short)0;		//	0是一个变量，其存的是short类型的
	(char)0;

	int a;			//int a；时编译器会自动给a分配一个内存地址，例如：0x12345678
	(int *)a;		//等价于(int *)0x12345678

	数据类型决定解析方法：例如：内存地址0x30000000 --> (int)0x30000000 :含义 0x30000000---0x30000003 中存储的是一个int类型的数据。
		强制类型转换：改变解析方式。

	C语言中函数就是一段代码的封装，函数名的实质就是这段代码的首地址。--> 函数名就是一个内存地址。

4.1.5.2 用指针来间接访问内存
	关于类型（不管是普通变量类型int float 等，还是指针类型 int * ，float *等），只要记住:类型是对后面的数字或者符号（代表的是内存地址）所表征的内存的一种长度规定和解析方法规定而已。
	C语言中的指针，全名叫指针变量，指针变量其实和普通变量没任何区别。例如：int a和int p其实没任何区别，a和p都代表一个内存地址（例如0x12345678）。 但是这个内存地址的长度和解析方法不同。

4.1.5.4 用数组来管理内存
	数组管理内存和变量其实没有本质区别，只是符号的解析方法不同。（普通变量、数组、指针变量其实都没有本质去呗，都是堆内存地址的解析，只是解析方法不一样）
	int a;			//编译器分配4个字节给a，并且把首地址和符号绑定起来。
	int b[10];		//编译器分配10 * 4 个字节给b，并且把首地址和符号b绑定起来。


	一、内存管理之结构体

1、数据结构这么学问的意义
	数据结构：研究数据如何组织（在内存找那个排布），如何加工的学问。

2、最简单的数据结构：数组
	类型相同、意义相关的变量需要管理 ---> 数组

	优势：简单、访问用下标、刻意随机访问

	缺陷：数组中所有元素类型必须相同、数组大小在定义时确定后期不能再更改

3、结构体
	为了解决数组的第一个缺陷（数组中元素类型必须相同）
	3个学生年龄：
	数组：int age[3];
	结构体：
	struct ages
	{
		int age1;
		int age2;
		int age3;
	};
	struct ages age;

	分析总结：这个示例中，数组要比结构体好，但是不能说数组臂结构体好，在包含元素类型不同时用数组就不合适了。例如：
	struct ages
	{
		int age;
		short name;
		float num;
	};

5、题外话：结构体内嵌入指针实现面向对象
	面向过程与面向对象。
	中的来说C语言是面向过程的，但是c语言写出的Linux系统是面向对象的。
	面向对象的语言，不一定不能实现面向对象的代码，只是说面向对象的语言来实现面向对象要更加简单一些、直观一些、无脑一些。
	c++、java等面向对象的语言来实现面向对象简单一些，因为语言本身帮我们做了很多事；但是用C语言来实现面向对象很麻烦，看起来也不容易理解，这就是为什么大多数人学过C语言却看不懂Linux内核代码的原因。
	struct s
	{
		int age;					//普通变量
		void (*pFunc)(void);		//函数指针，指向 void func(void)这类的函数
	}；
	
	使用这样的结构日就可以实现面向对象。
	这样包含了函数指针的结构体就类似与面向对象中的class，结构体找那个的变量就类似于class中的成员变量，结构体中的函数指针类似于class中的成员方法。


一、内存管理之栈（stack）

1、什么是栈
	一种数据结构，C语言中使用栈来保存局部变量。栈是管理内存的。

2、栈管理内存的特点（小内存、自动化）
	栈顶、栈底（该指针不变）。
	栈  ： 先进后出 first in last out;
	队列： 先进先出：first in first out  -->  FIFO

3、栈的应用举例：局部变量
	C语言中的 局部变量 是用栈来实现的。
	我们在C语言中定义一个局部变量时（int a）,编译器会在栈中分配一段空间（4字节）给这个局部变量用（分配时栈顶指针会移动给出空间，给局部变量a用的意思就是：这4字节的栈内存的内存地址和变量名绑定）。对应栈的操作是入栈。

	注意：这里栈的指针的移动和内存分配是自动的（栈自己完成，不用我们写代码去操作）

	然后等函数退出时，局部变量要灭亡。对应栈的操作是弹栈（出栈）。出栈时也是栈顶指针移动将栈空间中与a关联的空间释放（自动完成）

	优点：方便，分配和回收都不用程序员关心，系统自动完成。
	
	分析：C语言中，定义局部变量时如果未初始化，则值是随机的，为什么?
		定义局部变量，其实就是在栈中通过移动栈指针来给程序提供一个内存空间和这个局部变量绑定。因为这段内存空间在栈上，而栈内存是反复使用的，所以未初始化的局部变量其值是随机的。（栈内存容易 脏）

4、栈的约束（预定栈大小不灵活，怕溢出）
	栈有大小，其大小不好设置。太小容易溢出，太大怕浪费。
	栈溢出危害很大，一定要避免。

	C语言定义局部变量不能太大或太多。
	使用递归解决问题时，一定要注意递归收敛。

栈：小、申请用完后自动释放
	局部变量
堆：大、malloc申请 free释放

代码段：存放代码 + char *p = "linux"；(常量)

数据段：显示初始换非零的全局变量 + const 定义的局部变量 + 静态局部变量

bss段：显示初始化为0 或者 没有初始化的全局 的变量



文件：
		静态文件：	rom中
		动态文件：	ram中

	硬盘可以分为两个区域：1、硬盘内容管理表
						2、硬盘存储内容区

	操作系统寻找内容；  文件名--->硬盘内容管理表(获得对应的信息列表inode,i节点)--->硬盘存储内容区获得内容
						inode 本质是一个 结构体

	内存中打开的文件：这个文件属于相应的进程。每个进程都有一个结构体记录这个进程的所有信息(进程信息表)，
					进程信息表 ---> 文件管理表 ---> 文件(fd就是文件管理表中文件的索引)



动态文件在ram中是文件流的形式存在的。

在动态文件中有一个指针管理"文件光标" 这个文件指针就是vnode中的一个元素。
lseek:
		lseek 计算文件长度  lseek(fd,0,SEEK_END);
		lseek 生成空洞文件(文件中间有一段是空的)
			  ***应用场景：多线程同时操作文件即每个线程负责一段

同一个进程连续打开两次同一个文件，
	都去读：分别读	(文件指针分离)
	都去写：分别写	(文件指针分离)
	O_APPEND 可以将多个文件指针同步。	
	O_APPEND 对文件指针的影响是 原子的，
			原子操作：整个操作一单启动就不能被打断，只有这个操作结束其他的进程才能操作。

文件共享：同一个文件(同一个inode，同一个pathname)被多个独立的读写体(多个fd)去同时(打开而又未关闭)操作。 

文件描述符：进程表中文件描述符表(数组而非链表)中的一个表项，其作为index供使进程访问文件表指针(早期 fd 0~20，现在已经改了比较大)
			0 1 2 默认被进程打开，分别是 stdin stdout stderr 即：标准输入、标准输出、标准错误

文件描述符复制：
	dup	 ： fdnew = dup(fdold)
	dup2 ： 复制的fd去写入时是接续写(文件指针同步)


	> 重定位符号实现原理：open + close(1) + dup

fcntl:	fcntl(fd,cmd,...)

文件IO 与 标准IO
标准IO 基于 文件IO(操作系统API)
	ffulsh 刷新 (动态文件 -内容-> 静态文件)



二、文件属性
	Linux中文件类型
		普通文件
			文本文件	 ： ASCII码文件，本质上都是数字，该数字代表其对应的ASCII码(人很容易识别) .c .h .txt等
			二进制文件： 二进制文件本质上也是数字，这些数字不是文字编码是真正的数字。	(gcc编译生成的 a.out; arm-linux....生成的 .bin 等)

			本质上：两者没区别，区别是理解方式不同，解析为数字则是二进制文件，按照某种编码解析则是文本文件

	stat、fstat、lstat 是获取文件信息的API

	文件权限	st_mode 位在stat等函数的 struct stat 结构体中。使用时通过相应的掩码去获取出相应的位即可。

	文件属性： xxx xxx xxx ---> user group others 对改文件的操作权限
			  第一组  属主user	：系统当前登录的用户(即谁创建的谁就是谁) but chown 可以改变文件 user
			  第二组 所有组group	：

			  操作文件者的权限  有文件属性决定


	access函数 检查权限
		access(filename,F_OK/...)

	opendir
	readdir



可冲入函数：
	readdir函数：直接反悔了一个结构体，这个结构体只能是readdir函数申请的空间并且维护，返回了其地址，
				多次调用readdir函数并不会再次申请空间而是使用第一次申请的空间。其前后调用readdir
				 内部的结构体是有关联的
				 readdir ---> 这就是不可重入函数

	可重入函数：多次调用没有关联



Linux总时间相关的系统调度
(1) 常用的时间相关的API和库函数有9个：time、ctime、
(2)time 返回 ret 距离1970.1.1 0:0:0 的秒数 就是通过jiffies得到的，其他时间API、库函数都是以这个值为基准的
(3)ctime  ret --> 固定格式(年月日时分秒)
(4) gmtime(国际时间UTC) 和 localtime(本地时间、本地时区) 将ret转化为一个struct 保存。
(5) mktime可以将 struct --> ret
(6) asctime、strftime  : struct --> 固定格式(年月日时分秒)
(7) gettimeofday 、 settimeofday 

proc 文件系统 --> 调试内核
	(1)proc文件系统思路：在内核中构建一个虚拟文件系统/proc,内核运行时将内核中
	关键的数据结构以文件的方式呈现在/proc目录中的一些特定文件中，这样相当于
	将不可见的内核中的数据结构以可视化的方式呈现给内核的开发者。

	(2)使用方法：通过实时观察/proc/xxx文件，来观察内核中特定的数据结构的值。在
	我们添加一个新功能的前后对比，就可以知道这个新功能产生的影响对还是不对。

	(3)proc文件目录下的文件大小都是 0 ，因为他们都不存在与硬盘中，它也不是一个真实
	的文件，他只是一个街口，当我们去读这个文件时，其实内核并不是去硬盘上找这个文件
	，而是映射内核内部的一个数据结构，读取并且格式化为字符串返回。

常见proc文件介绍
(1)/proc/cmdline	
(2)/proc/cpuinfo
(3)/proc/devices
(4)/proc/interrupts

sys文件系统 --> 虚拟文件系统 (不存在与硬盘上,是内核找那个绝构体的可视化接口)

***
	与proc的区别：proc文件只能读，但是/sys中的文件可以读写。
***

进程：
	(1)进程的开始：编译链接时的引导代码。操作系统下的引用程序其实在main执行前也需要
			   先执行一段引导代码才能去执行main，我们写应用程序时不用考虑引导代码
			   的问题，链接时有链接器将编译中事先准备好的引导代码给链接进去，和我们
			   的应用程序一起构成最终的可执行程序。
	(2)运行时的加载器：加载器是操作系统中的程序，当我们去执行一个程序时(譬如./a.out、
		譬如代码中用exec族函数来运行)加载器负责将这个程序加载到内核中去执行这个程序。

	(3)程序在编译链接时用链接器，运行时用加载器，这两个东西对程序运行原理非常重要。

	(4)argc、argv传参 ： 已终端为例--> ./a.out xx --> shell这个进程 --> 加载器 
						--> 引导代码 --> main


	(5) 程序结束：
			正常终止：return exit _exit
					return ： 
			非正常终止：信号终止进程

	atexit 注册进程终止处理函数：
			atexit 注册多个进程终止函数。 和栈一样   先注册后执行。

	return exit _exit的差异：
		return和exit 一样会执行atexit注册进程终止函数 (这两个会执行回调函数，做一些处理)
		_exit        不会执行atexit注册进程终止函数	(不会执行回调函数，不做任何最后处理)

进程环境：
一、环境变量
	(1)export 命令查看环境变量
	(2)进程环境表介绍
		每一个进程中都有一份所有环境变量构成的一个表格，也就是当前进程中可以直接使用这些环境变量
		进程环境变量表是一个字符串数组。
	(3)进程中通过 environ 全局变量使用环境变量	
		getenv setenv--> 获取环境变量(只是获取当前进程的环境变量，不会改动系统环境变量)

	(4)我们写的程序中可以无条件直接使系统中的环境变量，所以一但程序中用到了环境变量那么程序就和
		操作系统环境有关了。	

二、进程运行的虚拟地址空间
	(1) 操作系统的每个进程都在独立的地址空间运行。
	(2) 每个进程的逻辑地址空间均为4G (32为系统)
	(3) 0~1G 为OS 1~4G 应用
	(4) 虚拟地址到物理地址空间的映射
	(5) 意义：
			1、进程隔离 			--> 安全性
			2、多进程同时运行		--> (运行地址必须与链接地址相等，程序才能运行。多进程运行时
									进程的物理地址是随机，此时链接地址没法确定，虚拟地址就
									解决了这个办法，让链接地址都为0，物理地址有操作系统解决)

三、进程引入
	(1)动态过程而非静态
		进程是程序的一次运行过程
	(2)进程控制块PCB(process control block)
		内核中用来管理一个进程的数据结构。

四、进程ID
	(1) getpid 、 getppid 、 getuid 、 geteuid 、 getgid 、 getegid
	(2) 实际用户ID和有效用户ID区别

五、多进程调度原理
	(1) 操作系统同时运行多个进程
	(2) 宏观上的并行和微观上的串行
	(3) 实际上现代操作系统最小调度单元是线性而不是进程

六、fork的内部原理
	(1) 进程的分裂生长模式
			如果操作系统需要一个新的进程来运行一个程序，那么操作系统会用一个现有的进程来复制生成一个新的进程。
			老进程叫父进程、新进程叫子进程。
	(2) fork实验
			fork 返回值  == 0 	子进程 中 ==0
						> 0  	父进程 中 > 0 其为子进程的pid

七、父子进程对文件的操作
	(1) 子进程继承父进程中打开的文件
		父进程 先 open 一个文件然后fork一个子进程
		同时对这个文件写		结果是接续写   类似于 O_APPEND
	(2)	父子进程各自独立打开同一文件实现共享
		分别写 -- > 出现覆盖   (O_APPEND 可以改变)
	(3) 总结
		父进程在没有fork之前做的事对子进程影响很大，而fork之后做的事对子进程没啥影响

		子进程最终目的是要独立的去运行类外的程序

八、进程的诞生和消亡
	(1) 进程0和进程1
	(2) fork
	(3) vfork

	进程的消亡：
		(1) 正常终止与异常终止
		(2) 进程在运行时需要消耗系统资源(内存、IO) ，进程终止时理应完全释放这些资源(如果进程在消亡后没有完全释放相应的资源则这些资源就丢失了)
		(3) Linux系统设计时规定：每一个进程退出时，操作系统会自动回收这个进程涉及到的所有资源(譬如malloc申请的内容没有free时，
								当前进程结束时这个内存会自动释放，譬如open打开的文件没有close，在程序终止时也会被关闭)。但是操作系统
								只是回收了这个进程工作时消耗的内幕才能和IO，而没有回收这个进程本身占用的内存(8Kb,主要是task_struct和栈内存
								(不是进程想操作系统申请的，而是fork时产生的，操作系统无法回收))

		(4) 因为进程本身的8KB内存操作系统不能回收需要别人来辅助回收，因此我们每个进程都需要一个帮助它收尸的人，这个人就是进程的父进程。

		僵尸进程：
			子进程结束，而父进程并为立刻帮子进程“收尸”，在这一段(子进程已经结束且父进程尚未帮其收尸)子进程就被称为僵尸进程。

			子进程出task_struct和栈外的内存空间已清理

			父进程可以通过 wait 和 waitpid 显示的回收子进程剩余内存并且获得子进程的退出状态。
			父进程也可以不用 wait 和 waitpid 来回收子进程的剩余内存，此时父进程结束时一样会回收子进程的剩余内存。(防止父进程忘记wait和waitpid回收，而造成内存泄漏)

			孤儿进程：
				父进程先于子进程结束。 --> 子进程就成为孤儿进程 。 Linux系统规定孤儿进程称为进程1(init进程) 的子进程。

	父进程wait回收子进程
	1、 工作原理：
		(1) 子进程结束时系统会向父进程发送SIGCHILD信号
		(2) 父进程调用wait后就会阻塞
		(3) 父进程被SIGCHILD唤醒后就会去回收僵尸子进程
		(4) 父子进程之间是异步的，SIGCHILD信号机制就是为了解决父子进程之间异步通信问题，让父进程及时回收僵尸子进程

		(5) 若父进程没有任何子进程 则wait 返回错误

	2、 wait实战
		(1) wait 参数 status。 status用来返回子进程结束时的状态，通过wait得到status后就可以知道子进程的一些结束状态信息。

	3、 waitpid实战
		id = waitpid(-1, &status, 0); -1：表示不等待特定pid
									  0 ：表示默认的方式

		id = waitpid(pid, &status, 0);	  等待pid这个子进程，如果没有这个pid的退出

	竞态
		(1) 竞争状态，多进程环境下，多个进程同时抢占系统资源(内存你、CPU、IO)
		(2) 竞争状态对OS来说是危险的，此时OS如果没处理好就会造成结果不确定。

九、exec族函数
	1、为什么需要exec族函数：
		(1) fork创建子进程是为了执行新程序。
		(2) 可以写在子进程的if结构中

		(3) exec族函数运行新的可执行程序(exec函数可以直接把一个编译好的可执行程序直接加载运行)

	2、 exec族函数介绍
		(1) execl 和 execv  		这两个事最基本的exec函数，区别是传参不同

		(2) execlp 和 execvp		这两个函数较上面两个多了个p，上面必须制定可执行程序的全路径，
								而这两个可以使file(也可以是path，只不过兼容了file，加了p的这两个
								函数会首先去找file，如果找到则执行，没找到回去环境变量PATH所指定的
								目录下找，找到执行，找不到则报错)

		(3) execle 和 execvpe	相较于execl多了个e 即 environ 环境变量。
				int main(int argc, char const *argv[],char **env)

十、进程状态和system函数
	1、进程的5种状态
		(1) 就绪态	运行条件满足，就差cpu
		(2) 运行态	就绪态得到CPU进入运行态
		(3) 僵尸态	进程已经结束但是父进程还没来得及回收
		(4) 等待态	(浅度睡眠 & 深度睡眠) 进程等待资源，得到该资源就可进入就绪态。前度睡眠可以被(信号)唤醒，
					深度睡眠时不能被唤醒，只能等待条件到了才能结束睡眠状态。
		(5) 暂停态	暂停并不是进程终止，只是被人(信号)暂停了，还是可以恢复的。

	2、 进程个状态之间的转换图
	3、 system函数介绍
		(1) system = fork + exec
		(2) 原子操作：整个操作一旦开始就必须操作。 好处:不会引来竞争状态。		坏处：占用cpu时间太长。

十一、进程关系
	1、无关系
	2、父子进程关系
	3、进程组(group)		由若干进程构成一个进程组
	4、会话(session)		会话就是进程组的组

十二、守护进程的引入
	1、 进程查看命令 ps
		(1) ps -aux 偏向显示进程各种占用资源
		(2) ps -ajx 偏向显示各种有关的ID号

	2、 向进程发送信号指令 kill
		(1) kill -信号编号 进程ID
		(2) kill -9 xxx

	3、 守护进程
		(1) daemon				守护进程，简称d
		(2) 长期运行 (一般是开机运行指导关机时结束)
		(3) 与控制台脱离			普通进程都与终端相绑定，终端关闭则这个终端下的进程全部被强制关闭，背后的问题在于会话
		(4) 服务器(server)		服务器程序就是一个一直在运行的程序，给我们提供某种服务(譬如nfs服务器)

		(5) 常见的守护进程
			syslogd		: 系统日志守护进程，提供syslog功能
			cron		: cron进程用来实现操作系统时间管理，Linux中实现定时执行程序的功能就要用到cron。

		(6) 编写守护进程
			(1) 子进程等待父进程退出
			(2) 子进程使用setsid创建新的会话，脱离控制台
			(3) 调用chdir将当前工作目录设置为/
			(4) umask设置为0以取消任何文件权限屏蔽
			(5) 关闭所有文件描述符
			(6) 将0、1、2定位到/dev/null

	4、使用syslog来记录调试信息
		openlog ： 
		syslog  ： 
		closelog： 

		log信息一般都在/var/log/message这个文件中。
		Ubuntu中在：/var/log/syslog文件中。

		syslog工作原理：
			(1)操作系统有一个守护进程syslogd(开机运行，关机结束)，这个守护进程
				syslogd负责进行日志文件写入和维护。
			(2)syslogd是独立与我们任何一个进程而运行的，我们当前进程和syslogd进程本来是没有任何
				关系的，但是我们当前进程可以通过调用openlog打开一个和syslogd想链接的通道，然后通过
				syslog想syslogd发消息，然后又syslogd来将其写入日志文件中。
			(3)syslogd其实就是一个日志文件系统的服务进程，提供日志服务。任何需要些日志的进程都可以
				通过/openlog/syslog/closelog这三个函数来利用syslogd提供的日志服务。这就是操作系统
				的服务式设计。

	5、守护进程长时间运行而不退出，因此我们需要这个进程只运行一个就可以(单例运行)。
		单例运行：一个程序的进程没有运行则运行，如果运行了就直接退出。

		实现方法：用一个文件的存在与否来做标志。具体的做法就是在执行之处去判断一个特定的文件是否存在，
				若存在则标明已经运行，若不存在则标明没有运行。然后运行程序时区创建这个文件。当程序结束的
				时候去删除这个文件即可。(文件名要特殊以确保系统中不存在)


十三、进程间通信(IPC)
	1、为什么需要进程间通信
		(1) 进程间通信(IPC)指的是2个任意进程之间的通信。
		(2) 同一个进程在一个地址空间中，所以同一个进程的不同模块(不同函数、不同文件)之间比较简单(很多时候是全局变量、函数参数传递)。
		(3) 两个不同的进程处于不同的地之间空间，因此要互相通信很难。

	2、 什么样的程序需要进程间通信
		(1) 绝大部分程序都是不需要进程间通信的。因此大部分程序都是单进程的(可以多线程)
		(2) 复杂、大型的程序，因为设计的需要就必须设计成多进程程序(我们整个程序就设计成多个进程同时工作来完成的模式)，常见的如GUI、服务器。
		(3) 结论：IPC 技术一般中小型程序中用不到，在大型程序中才会用到。

	3、 Linux内核提供多种进程间通信机制
		(1) 无名管道、有名管道
				无名管道(管道)： *** 单向通信 ---> 半双工 ***
					原   理	：内核维护的一块内存，有读端和写端
					实现方法 ：父进程创建管道后fork子进程，子进程继承父进程的管道id。
					限	制	： 只能在父子进程间通信。
					函数(API)：pipe、write、read、close

				有名管道(fifo)： first in first out 先进先出   <--->   (stack 先进后出)
					原   理  ：	内核维护的一块内存，表现形式为一个文件
					使用方法  ： 固定一个文件名，2个进程分别使用mkfifo创建文件，然后分别open打开获取fd，然后一个读一个写
					限	制	 ：半双工(but 不限父子进程)
					函数API : mkfifo、open、write、read、close

		(2) SystemV IPC : 信号量、消息队列、共享内存	(内核维护的一段公共内存)
				信 号 量 ： 
					(1) 实质就是一个计数器(其实就是一个可以用来计数的变量，可以理解为ina a)
					(2) 目的：实现互斥与同步
				消息队列 ： 
					(1) 本质上是一个队列，可以理解(内核维护了一个)为FIFO
					(2) 工作时A和B 2个进程进行通信，A向队列中放入消息，B从队列中读出消息。
				共享内存 ： 
					(1) 大片内存直接映射
					(2) 类似于LCD显示时的显存用法
		(3) Socket域套接字
		(4) 信号 

十四、信号
	1、什么是信号(可以理解是一种软件中断)
		(1) 内容受限的一种异步通信机制
		(2) 目的：通信 (进程间)，内容少
		(3) 信号是异步的(对比硬件中断)
		(4) 本质上是int型数字编号(事先定义好的)
	2、常见信号介绍
		(1) 用户在终端按下按键
		(2) 硬件异常后由操作系统内核发出信号
		(3) 用户使用kill命令向其他进程发出信号
		(4) 某种软件条件满足后也会发出信号，如alarm闹钟时间到会产生SIGALARM信号，向一个读端已经关闭
			write时产生SIGPIPE信号
	3、谁处理、如何处理
		(1) 忽略信号 
		(2) 捕获信号 (信号绑定了一个函数)
		(3) 默认处理 (当前进程没有明显的管这个信号，默认：忽略 或者 终止进程)

	4、常见信号介绍
		(1) SIGINT				2			Ctrl+c时OS发送给前台进程组中每个进程
		(2) SIGABRT				6			调用abort函数，进程异常终止
		(3) SIGPOLL 	SIGIO	8			指示一个异步IO事件，在高级IO中提及
		(4) SIGKILL				9			杀死进程的终极办法
		(5) SIGSEGV				11			无效存储访问时OS发出该信号
		(6) SIGPIE 				13			设计管道和socket
		(7) SIGALARM 			14			涉及alarm函数的实现
		(8) SIGTERM				15			kill命令发送的OS默认终止信号
		(9) SIGCHLD 			17			子进程终止或停止时OS向其父进程发送此信号
		(10) 
			SIGUSR1				10			用户自定义信号，作用和意义由应用自己定义
			SIGUSR2				12			

	5、进程对信号的处理
		(1) signal 函数绑定捕获函数 即：信号处理函数
		(2) signal 返回值：信号发送后
		细节：signal函数绑定一个捕获函数后信号发生后自动执行绑定的捕获函数，并且把信号编号作为传参穿个捕获函数
			signal返回值：在出错时：SIG_ERR。		绑定成功时返回旧的捕获函数

			注：绑定捕获函数少用，移植性较差。可以用sigaction.

		sigaction函数可以设置新的捕获函数，也可以得到旧的指针函数。

	6、alarm函数
		(1) 内核只为每个进程维护一个 alarm
		(2) alarm 函数返回值为上次剩余的时间

	7、pause函数
		(1) 当前进程挂起交出cpu

十五、高级IO
	1、非阻塞IO
		阻塞：
			(1) 阻塞：当前进程调用的函数进入到内核后因为当前进程不满足而挂起
			(2) 为什么需要阻塞式
			(3) 常见的阻塞：wait、pause、sleep等函数； read、write某些文件时。
			(4) 阻塞的好处：有利于操作系统的性能发挥。

		非阻塞：
			(1) 为什么要实现非阻塞(阻塞式在多路IO时可能会出问题)
			(2) 实现 O_ONNBLOCK   fcntl

	2、阻塞式IO的困境
		(1) 程序中读取键盘
		(2) 程序中读取鼠标
		(3) 程序中同时读取键盘与鼠标
	3、并发式IO
		(1) 非阻塞式IO
		(2) 多路复用IO
		(3) 异步通知(异步IO)

	4、IO多路复用原理
		外部阻塞式、内部非阻塞式自动轮训多路阻塞式IO
		(1) select
		(2) poll 

	5、异步IO
		(1) 几乎可以认为异步IO就是操作系统用软件实现的一套中断相应系统。
		(2) 异步IO的工作方法是：我们当前进程注册一个异步IO事件(使用signal注册一个信号SIGIO的处理函数)，
			当前进程可以正常处理自己的事情，当一部事件发生后当前进程会受到一个SIGIO喜好从而执行绑定的处理函数
			去处理这个异步事件。

		(3) 涉及到的函数：
			(1) fcntl (F_GETFL、F_SETFL、O_ASYNC(指示当前fd可以接受异步通知)、F_SETOWN(设置异步通知接受进程))
			(2) signal 或者 sigaction (SIGIO)

	6、内存映射
		(1) mmap 共享而不是复制，处理大文件而非小文件

	void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);


十六、线程
	1、进程的优势：
		(1) CPU时分复用，单核心CPU可以实现宏观上的并行
		(2) 实现多任务需求(多任务的需求是客观的)
	2、进程的劣势
		(1) 进程间切换开销的
		(2) 进程间通信麻烦而且效率低

		(3) 解决方案就是线程技术
			(1) 线程技术保留了进程技术实现多任务的特性。
			(2) 线程的改进就是线程间切换和线程间通信上提升了效率
			(3) 过线程在多核心CPU上面更有优势

	3、线程的引入
		(1) 一种轻量级的进程
		(2) 线程是操作系统调度的最小单元
		(3) 一个进程可以有多个线程
	4、线程技术的优势
		(1) 像进程一样可以被OS调度
		(2) 同一个进程的多个线程之间很容易高效通信
		(3) 在多核心CPU(对称多处理器架构SMP)架构下效率最大化

	5、线程常见函数
		(1) 线程创建与回收
			(1) pthread_create		主线程用来创建子线程
			(2) pthread_join		主线程用来等待(阻塞)回收子线程
			(3) pthread_detach		主线程用来分离子线程，分离后主线程不必再去回收子线程
		
		(2) 线程取消
			(1) pthread_cancel			一般都是主线程调用该函数取消(kill)子线程
			(2) pthread_setcancelstate	子线程设置自己是否允许被取消
			(3) pthread_setcanceltype	设置子线程取消模式(立即over or wait can over)

		(3) 线程函数退出		(不能使用  exit，他会退出进程)
			(1) pthread_exit 与 return 退出

			(2) pthread_cleanup_push		子线程带锁情况下 exit ，没有ulock，这个函数可以解决这个问题
			(3) pthread_cleanup_pop

		(4) 获取线程id
			(1) pthread_self

	6、线程同步之信号量
		(1) 任务：用户从终端输入任意字符然后统计个数显示，输入end结束。

		(2) 线程同步：子线程被阻塞，主线程可以激活，这就是线程的同步
				(1) API:
						sem_init();
						sem_post();
						sem_wait();
						sem_destroy();

	7、线程同步之互斥锁 (mutex)
		(1) API:
				pthread_mutex_init();			pthread_mutex_destroy();
				pthread_mutex_lock();			pthread_mutex_unlock();
		
		(2) 互斥锁与信号量的关系		(只有 0和1 的信号量)
				互斥锁是一种特殊的信号量。

		(3) 互斥锁主要用来实现关键段的保护

	8、线程同步之条件变量  	(阻塞与等待)
		(1) API :
				pthread_cond_init		pthread_cond_destroy
				pthread_cond_wait		pthread_cond_signal(单个唤醒)/thread_cond_broadcast(唤醒全部)


十七、网络编程
	1、 基础知识
		1、
			(1) 网络通信其实就是网络中不同(相同)主机上面的2个进程之间的通信。
			(2) 网卡 --> 网卡驱动 --> API(socket接口)
			(3) 应用层：低级 		(直接基于socket接口编程)
			(4) 应用层：高级 		(基于网络通信应用框架库)
			(5) 应用层：更高级 	(http、网络控件等)

		2、学习方法
			(1) 重点1：掌握网络通信的架构层次和基本原理
			(2) 重点2：掌握socket及其相关函数的使用
			(3) 重点3：掌握服务器和客户端程序通信的方法

	2、 基础知识
		1、
			(1) 单机阶段
			(2) 局域网阶段
			(3) 广域网internet阶段
			(4) 移动互联网阶段
			(5) 物联网阶段
		2、三大网络
			(1) 电信网、电视网络、互联网
		3、网络通信的传输没接
			(1) 无线传输：WIFI、蓝牙、zigbee、4G/5G/GPRS等
			(2) 有线通信：双绞线、同轴电缆、光纤等

	3、 网络通信基础知识
		(1) OSI 7层网络模型 
					--> 物理层 数据链路层 网络层 传输层 会话层 表示层 应用层 

		(2) 网卡 (隔离与连接)
			(1) 计算机上网必备硬件设备，CPU考网卡来连接外部网络
			(2) 串转并 设备   cpu <- 并行 -> 网卡    网卡 <- 串行全双工、差分 -> 外部网络
			(3) 作用：数据帧 的封包和拆包  包头有网卡解决
			(4) 网络数据缓存和速率适配

		(3) 集线器 (广播 效率低)
			(1) 信号放大，相当于中继器
			(2) 组成局域网络，用广播方式工作
			(3) 集线器不能用来连接外网的

		(4) 交换机 (有地址映射表，可实现定向发送数据。第一次发送时找不到则广播然后就可以建立表)
			(1) 包含集线器的功能，但更高级
			(2) 交换机中有地址表，数据包查表后直达目的通信口而不是广播
			(3) 找不到目的的口时广播学习

		(5) 路由器
			(1) 路由器是局域网和外网通信的出入口
			(2) 路由器将整各internet划分成一个个的局域网，却又互相联通
			(3) 路由器对对内管理子网(局域网)，可以再路由器中设置子网的网段，设置有线端口的IP地址，
				设置dhcp功能等，因此局域网的IP地址是路由器决定的。

				WAN:路由器对外
				LAN:路由器对内

			(4) 路由器对外实现联网，联网方式取决于外部网络(如ADSL拨号上网、宽带账号、局域网等)。这时候
				路由器有相当于是更高级网络的其中一个节点而已。

			(5) 所以路由器相当于有两个网卡，一个对内做网关，一个对外做节点。
			(6) 路由器的主要功能是为经过路由器的每个数据包寻找一条最佳(路由)并转发出去。其实就是局域网内
				电脑要发送到外网的数据包，和外网回复给局域网内电脑的数据包。
			(7) 路由器技术是网络中最重要技术，决定了网络的稳定性和速度。

		(6) DNS(Domain Name Service 域名服务)
			(1) 网络世界的门牌号：IP地址
			(2) IP地址的缺点：难记、不直观
			(3) IP地址的替代产品：域名
			(4) DNS服务器就是专门提供域名和IP地址之间的转换的服务的，因此域名要购买的
			(5) 我们访问一个网站的流程是：先使用IP地址访问DNS服务器，查询我们要访问的域名的IP地址，然后
				再使用该IP地址访问我们真正要访问的网站。这个过程被浏览器封装屏蔽，其中使用的就是DNS协议。
			(6) 浏览器需要DNS服务器，而QQ这样的客户端却不要(因为QQ软件编程时已经知道了腾讯的服务器IP地址，
				因此可以直接IP方式访问服务器)

		(7) DHCP（dynamic host configuration protocl,动态主机配置协议）
			(1) 每台计算机都需要一个IP地址，且局域网内个电脑IP地址不能重复，否则会地址冲突。
			(2) 计算机的IP地址可以静态设定，也可以动态分配。
			(3) 动态分配是局域网内的DHCP服务器来协调的，很多设备都能提供DHCP功能，譬如路由器。
			(4) 动态分配的优势：为了方便接入和断开、有限的IP地址得到充分利用

		(8) NAT (network address translation 网络地址转换协议)
			(1) IP地址分为公网IP(internet 范围内唯一的IP地址)和私网IP(内网IP)
			(2) 网络通信的数据包中包含有目的地址的IP地址
			(3) 当局域网中的主机要发送数据包给外网时，路由器要负责将数据包头中的局域网主机的内网IP替换为
				当前局域网的对外外网IP。这个过程就叫NAT。
			(4) NAT的作用是缓解IPv4的IP地址不够用的问题，但只是类似于打补丁的形式，最终的解决方案还是考IPv6
			(5) NAT穿透介绍

		(9) IP地址
			(1) IP地址分类：(IPv4)
				(1) IP地址实际是一个32位的二进制构成，在网络通信数据包中就是32位的IP地址，而在人机交互中
					使用点分十进制方式显示。
				(2) IP地址中32位其实是包含两部分。分别为：网络地址和主机地址。子网掩码，用来说明网络地址和
					主机地址各占多少位。

					IP地址 = 网络地址 + 主机地址
					网络地址：表示子网	
					主机地址：表示子网中的主机硬件

					8位表示网络、24位表示主机；16 、 16 ； 

					子网掩码：255.255.255.0 ：前24位为网络地址，后8位为主机地址
						(1) 子网掩码为 255.255.255.0 时表示这个网络中可以有2^(24)个网络，每个这种网络下可以有
							2^8个主机
				(3) 有网络地址和主机地址分别占多少位的不同，将IP地址分为5类，最常用的有三类。

					(1) A类
					(2) B类
					(3) C类

					(4) 127.0.0.0用来测试回环测试 lookback

				(4) 如何判断2个IP地址是在同一个子网内
					(1) 网络标识 = IP地址 & 子网掩码
					(2) 2个IP地址的网络标识一样，那么就处于同一网络。

	4、网络编程框架
		1、
			(1) Linux网络编程框架
				(1) 网络分层 OSI 7层模型
				(2) 网络为什么要分层
				(3) 网络分层的具体表现

				2、BS CS
					CS架构介绍： (client server, 客户端服务器架构)
					BS架构介绍： (broswer server，浏览器服务器架构)
			(2) TCP/IP 协议的学习 
				1、
					(1) TCP协议工作在传输层，对上服务socket接口，对下调用IP层
					(2) TCP协议面向连接，通信前必须先3次握手建立连接关系后才能开始通信。
					(3) TCP协议提供可靠传输，不怕丢包、乱序等。

					TCP如何保证可靠传输
						(1) TCP在传输有效信息前要求通信双方必须先握手，建立连接才能通信
						(2) TCP的连接放收到数据包后会发送ack给发送方，若发送方为收到ack后 丢包重传。
						(3) TCP的有效数据内容会附带校验，以防止内容在传递过程中损坏
						(4) TCP会根据网络贷款来自动调节适配速率 (滑动窗口技术)
						(5) 发送方会给个分割报文编号，接收方会校验编号，一单顺序错误即会重传。
				2、
					(1) TCP的三次握手
						(1) 建立连接需要三次握手
								C ---    SYN  	--->  S 		SYN : 同步
								C <--- SYN+ACK  ---   S 		ACK : 回应
								C ---    ACK    --->  S
						(2) 建立连接的条件：服务器listen时客户端主动发起connect

					(2) TCP的四次握手
						(1) 服务器和客户端都可以主动发起关闭
								C --- FIN --- S 		>
								C --- ACK --- S 		<
								C --- FIN --- S 		>
								C --- ACK --- S 		<

					注：这些协议已经封装在TCP协议内部，socket编程接口平时都不用管

					(1) 基于IP地址的服务模式
						(1) 具有公网IP地址的服务器(或者使用动态IP地址映射技术)
						(2) 客户端socket、bind、listen后处于监听状态
						(3) 服务端socket后，直接connect去发起连接。
						(4) 服务器收到并同意客户端接入后会建立TCP连接，然后双方开始收发数据，
							收发时是双向的，而且双方均可发起。
						(5) 双方均可发起关闭连接。

					(2) 常见的使用了TCP协议的网络应用
						(1) http、ftp
						(2) QQ服务器 
						(3) mail服务器

			(3) socket编程接口
					(1) 建立连接 
						(1) socket  
							int socket(int domain, int type, int protocol);  
							domain:域  IPv4 还是 IPv6
							type ： 连接方式  TCP or UDP

							socket函数类似于open，用来打开一个网络连接，如果成功则返回一个网络文件描述符(int类型)
							之后我们操作这个网络连接都通过这个网络文件描述符。
						(2) bind 
							int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
							sockfd : socket 函数返回的网络连接描述符

						(3) listen 
							int listen(int sockfd, int backlog);
							backlog：表示同时可以监听个数
						(4) connect
							int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
							const struct sockaddr *addr ： 服务器IP地址



					(2) 发送和接收
						(1) send 和 write 
						(2) recv 和 read 

					(3) 辅助性函数	-->	IP地址转换  
						以下支持IPv4
						(1) inet_aton	
						(2) inet_addr	
						(3) inet_ntoa	
						以下支持IPv6   n：可以理解为网络端使用的   32位二进制
									  p：可以理解为字符串			192.168.0.0
						(4) inet_ntop	
						(5) inet_pton	

					(4) 表示IP地址相关数据结构
						(1) struct sockaddr, 这个结构体是网络编程接口中用来表示一个IP地址的，注意这个IP地址是不区分
							IPv4还是IPv6的，即：兼容IPv4 与 IPv6
						(2) typedef uint32_t in_addr_t;  网络内不用来表示IP地址的类型
						(3) struct in_addr 
							{
								in_addr_t s_addr;
							}
						(4) truct sockaddr_in
						    {
							    __SOCKADDR_COMMON (sin_);			/*地址族IPv4 IPv6*/
							    in_port_t sin_port;                 /* Port number.  */
							    struct in_addr sin_addr;            /* Internet address.  */

							    /* Pad to size of `struct sockaddr'.  */
							    unsigned char sin_zero[sizeof (struct sockaddr)
							                           - __SOCKADDR_COMMON_SIZE
							                           - sizeof (in_port_t)
							                           - sizeof (struct in_addr)];
						  	};
						 (5) struct sockaddr。		
						 		这个结构体是Linux网络编程中用来表示IP地址的标准结构体，bind、connect等函数中都需要这个结构体，
						 		这个结构体是兼容IPv4和IPv6的。	在实际编程中这个结构体会被一个struct sockaddr_in或者
						 		一个struct sockaddr_in6所填充。



		3、socket编程实践
			(1) 服务器
					(1) socket
					(2) bind
					(3) listen
					(4) accept
	
			(2) 客户端
					(1) socket 
					(2) connect

			注意：端口号，实质就是一个数字编号，用来在我们一台主机中(主机的操作系统中)位移的标识一个能上网的进程
				 端口号和IP地址一起打包到当前进程发出或者接收到的每一个数据包。每一个数据包将来在网络上传递的时候
				 ，内部都包含了发送方和接收方的信息(就是IP地址和端口号)，所以IP地址和端口号这两个往往打包在一起不分家。

		4、socket编程实践
			(1) 客户端 给 服务器
			(2) 服务器 给 客户端

		5、探讨：如何让服务器和客户端好好沟通
			(1) 客户端与服务器原则上都可以任意发和收，但实际上双方必须配合：client发的时候service就收，而service发的
				时候client就收。
			(2) 必须了解到一点：client和service之间的通信时异步的，这就是问题的根源
			(3) 解决方案：依靠应用层协议来解决。说白了就是我们service和client事先做好一系列的通信约定。

		6、socket编程实践
			(1) 自定义应用层协议第一步：规定发送和接收方法
				(1) 规定连接建立后由客户端主动向服务器发出一个请求数据包，然后服务器收到数据包后回复客户端一个回应数据包
					，这就是一个通信回合。
				(2) 整个连接的通信就是由n多个回合组成的。

