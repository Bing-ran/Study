文件：
		静态文件：	rom中
		动态文件：	ram中

	硬盘可以分为两个区域：1、硬盘内容管理表
						2、硬盘存储内容区

	操作系统寻找内容；  文件名--->硬盘内容管理表(获得对应的信息列表inode,i节点)--->硬盘存储内容区获得内容
						inode 本质是一个 结构体

	内存中打开的文件：这个文件属于相应的进程。每个进程都有一个结构体记录这个进程的所有信息(进程信息表)，
					进程信息表 ---> 文件管理表 ---> 文件(fd就是文件管理表中文件的索引)



动态文件在ram中是文件流的形式存在的。

在动态文件中有一个指针管理"文件光标" 这个文件指针就是vnode中的一个元素。
lseek:
		lseek 计算文件长度  lseek(fd,0,SEEK_END);
		lseek 生成空洞文件(文件中间有一段是空的)
			  ***应用场景：多线程同时操作文件即每个线程负责一段

同一个进程连续打开两次同一个文件，
	都去读：分别读	(文件指针分离)
	都去写：分别写	(文件指针分离)
	O_APPEND 可以将多个文件指针同步。	
	O_APPEND 对文件指针的影响是 原子的，
			原子操作：整个操作一单启动就不能被打断，只有这个操作结束其他的进程才能操作。

文件共享：同一个文件(同一个inode，同一个pathname)被多个独立的读写体(多个fd)去同时(打开而又未关闭)操作。 

文件描述符：进程表中文件描述符表(数组而非链表)中的一个表项，其作为index供使进程访问文件表指针(早期 fd 0~20，现在已经改了比较大)
			0 1 2 默认被进程打开，分别是 stdin stdout stderr 即：标准输入、标准输出、标准错误

文件描述符复制：
	dup	 ： fdnew = dup(fdold)
	dup2 ： 复制的fd去写入时是接续写(文件指针同步)


	> 重定位符号实现原理：open + close(1) + dup

fcntl:	fcntl(fd,cmd,...)

文件IO 与 标准IO
标准IO 基于 文件IO(操作系统API)
	ffulsh 刷新 (动态文件 -内容-> 静态文件)



二、文件属性
	Linux中文件类型
		普通文件
			文本文件	 ： ASCII码文件，本质上都是数字，该数字代表其对应的ASCII码(人很容易识别) .c .h .txt等
			二进制文件： 二进制文件本质上也是数字，这些数字不是文字编码是真正的数字。	(gcc编译生成的 a.out; arm-linux....生成的 .bin 等)

			本质上：两者没区别，区别是理解方式不同，解析为数字则是二进制文件，按照某种编码解析则是文本文件

	stat、fstat、lstat 是获取文件信息的API

	文件权限	st_mode 位在stat等函数的 struct stat 结构体中。使用时通过相应的掩码去获取出相应的位即可。

	文件属性： xxx xxx xxx ---> user group others 对改文件的操作权限
			  第一组  属主user	：系统当前登录的用户(即谁创建的谁就是谁) but chown 可以改变文件 user
			  第二组 所有组group	：

			  操作文件者的权限  有文件属性决定


	access函数 检查权限
		access(filename,F_OK/...)

	opendir
	readdir



可冲入函数：
	readdir函数：直接反悔了一个结构体，这个结构体只能是readdir函数申请的空间并且维护，返回了其地址，
				多次调用readdir函数并不会再次申请空间而是使用第一次申请的空间。其前后调用readdir
				 内部的结构体是有关联的
				 readdir ---> 这就是不可重入函数

	可重入函数：多次调用没有关联



Linux总时间相关的系统调度
(1) 常用的时间相关的API和库函数有9个：time、ctime、
(2)time 返回 ret 距离1970.1.1 0:0:0 的秒数 就是通过jiffies得到的，其他时间API、库函数都是以这个值为基准的
(3)ctime  ret --> 固定格式(年月日时分秒)
(4) gmtime(国际时间UTC) 和 localtime(本地时间、本地时区) 将ret转化为一个struct 保存。
(5) mktime可以将 struct --> ret
(6) asctime、strftime  : struct --> 固定格式(年月日时分秒)
(7) gettimeofday 、 settimeofday 

proc 文件系统 --> 调试内核
	(1)proc文件系统思路：在内核中构建一个虚拟文件系统/proc,内核运行时将内核中
	关键的数据结构以文件的方式呈现在/proc目录中的一些特定文件中，这样相当于
	将不可见的内核中的数据结构以可视化的方式呈现给内核的开发者。

	(2)使用方法：通过实时观察/proc/xxx文件，来观察内核中特定的数据结构的值。在
	我们添加一个新功能的前后对比，就可以知道这个新功能产生的影响对还是不对。

	(3)proc文件目录下的文件大小都是 0 ，因为他们都不存在与硬盘中，它也不是一个真实
	的文件，他只是一个街口，当我们去读这个文件时，其实内核并不是去硬盘上找这个文件
	，而是映射内核内部的一个数据结构，读取并且格式化为字符串返回。

常见proc文件介绍
(1)/proc/cmdline	
(2)/proc/cpuinfo
(3)/proc/devices
(4)/proc/interrupts

sys文件系统 --> 虚拟文件系统 (不存在与硬盘上,是内核找那个绝构体的可视化接口)

***
	与proc的区别：proc文件只能读，但是/sys中的文件可以读写。
***

进程：
	(1)进程的开始：编译链接时的引导代码。操作系统下的引用程序其实在main执行前也需要
			   先执行一段引导代码才能去执行main，我们写应用程序时不用考虑引导代码
			   的问题，链接时有链接器将编译中事先准备好的引导代码给链接进去，和我们
			   的应用程序一起构成最终的可执行程序。
	(2)运行时的加载器：加载器是操作系统中的程序，当我们去执行一个程序时(譬如./a.out、
		譬如代码中用exec族函数来运行)加载器负责将这个程序加载到内核中去执行这个程序。

	(3)程序在编译链接时用链接器，运行时用加载器，这两个东西对程序运行原理非常重要。

	(4)argc、argv传参 ： 已终端为例--> ./a.out xx --> shell这个进程 --> 加载器 
						--> 引导代码 --> main


	(5) 程序结束：
			正常终止：return exit _exit
					return ： 
			非正常终止：信号终止进程

	atexit 注册进程终止处理函数：
			atexit 注册多个进程终止函数。 和栈一样   先注册后执行。

	return exit _exit的差异：
		return和exit 一样会执行atexit注册进程终止函数 (这两个会执行回调函数，做一些处理)
		_exit        不会执行atexit注册进程终止函数	(不会执行回调函数，不做任何最后处理)

进程环境：
一、环境变量
	(1)export 命令查看环境变量
	(2)进程环境表介绍
		每一个进程中都有一份所有环境变量构成的一个表格，也就是当前进程中可以直接使用这些环境变量
		进程环境变量表是一个字符串数组。
	(3)进程中通过 environ 全局变量使用环境变量	
		getenv setenv--> 获取环境变量(只是获取当前进程的环境变量，不会改动系统环境变量)

	(4)我们写的程序中可以无条件直接使系统中的环境变量，所以一但程序中用到了环境变量那么程序就和
		操作系统环境有关了。	

二、进程运行的虚拟地址空间
	(1) 操作系统的每个进程都在独立的地址空间运行。
	(2) 每个进程的逻辑地址空间均为4G (32为系统)
	(3) 0~1G 为OS 1~4G 应用
	(4) 虚拟地址到物理地址空间的映射
	(5) 意义：
			1、进程隔离 			--> 安全性
			2、多进程同时运行		--> (运行地址必须与链接地址相等，程序才能运行。多进程运行时
									进程的物理地址是随机，此时链接地址没法确定，虚拟地址就
									解决了这个办法，让链接地址都为0，物理地址有操作系统解决)

三、进程引入
	(1)动态过程而非静态
		进程是程序的一次运行过程
	(2)进程控制块PCB(process control block)
		内核中用来管理一个进程的数据结构。

四、进程ID
	(1) getpid 、 getppid 、 getuid 、 geteuid 、 getgid 、 getegid
	(2) 实际用户ID和有效用户ID区别

五、多进程调度原理
	(1) 操作系统同时运行多个进程
	(2) 宏观上的并行和微观上的串行
	(3) 实际上现代操作系统最小调度单元是线性而不是进程

六、fork的内部原理
	(1) 进程的分裂生长模式
			如果操作系统需要一个新的进程来运行一个程序，那么操作系统会用一个现有的进程来复制生成一个新的进程。
			老进程叫父进程、新进程叫子进程。
	(2) fork实验
			fork 返回值  == 0 	子进程 中 ==0
						> 0  	父进程 中 > 0 其为子进程的pid

七、父子进程对文件的操作
	(1) 子进程继承父进程中打开的文件
		父进程 先 open 一个文件然后fork一个子进程
		同时对这个文件写		结果是接续写   类似于 O_APPEND
	(2)	父子进程各自独立打开同一文件实现共享
		分别写 -- > 出现覆盖   (O_APPEND 可以改变)
	(3) 总结
		父进程在没有fork之前做的事对子进程影响很大，而fork之后做的事对子进程没啥影响

		子进程最终目的是要独立的去运行类外的程序

八、进程的诞生和消亡
	(1) 进程0和进程1
	(2) fork
	(3) vfork

	进程的消亡：
		(1) 正常终止与异常终止
		(2) 进程在运行时需要消耗系统资源(内存、IO) ，进程终止时理应完全释放这些资源(如果进程在消亡后没有完全释放相应的资源则这些资源就丢失了)
		(3) Linux系统设计时规定：每一个进程退出时，操作系统会自动回收这个进程涉及到的所有资源(譬如malloc申请的内容没有free时，
								当前进程结束时这个内存会自动释放，譬如open打开的文件没有close，在程序终止时也会被关闭)。但是操作系统
								只是回收了这个进程工作时消耗的内幕才能和IO，而没有回收这个进程本身占用的内存(8Kb,主要是task_struct和栈内存
								(不是进程想操作系统申请的，而是fork时产生的，操作系统无法回收))

		(4) 因为进程本身的8KB内存操作系统不能回收需要别人来辅助回收，因此我们每个进程都需要一个帮助它收尸的人，这个人就是进程的父进程。

		僵尸进程：
			子进程结束，而父进程并为立刻帮子进程“收尸”，在这一段(子进程已经结束且父进程尚未帮其收尸)子进程就被称为僵尸进程。

			子进程出task_struct和栈外的内存空间已清理

			父进程可以通过 wait 和 waitpid 显示的回收子进程剩余内存并且获得子进程的退出状态。
			父进程也可以不用 wait 和 waitpid 来回收子进程的剩余内存，此时父进程结束时一样会回收子进程的剩余内存。(防止父进程忘记wait和waitpid回收，而造成内存泄漏)

			孤儿进程：
				父进程先于子进程结束。 --> 子进程就成为孤儿进程 。 Linux系统规定孤儿进程称为进程1(init进程) 的子进程。

	父进程wait回收子进程
	1、 工作原理：
		(1) 子进程结束时系统会向父进程发送SIGCHILD信号
		(2) 父进程调用wait后就会阻塞
		(3) 父进程被SIGCHILD唤醒后就会去回收僵尸子进程
		(4) 父子进程之间是异步的，SIGCHILD信号机制就是为了解决父子进程之间异步通信问题，让父进程及时回收僵尸子进程

		(5) 若父进程没有任何子进程 则wait 返回错误

	2、 wait实战
		(1) wait 参数 status。 status用来返回子进程结束时的状态，通过wait得到status后就可以知道子进程的一些结束状态信息。

	3、 waitpid实战
		id = waitpid(-1, &status, 0); -1：表示不等待特定pid
									  0 ：表示默认的方式

		id = waitpid(pid, &status, 0);	  等待pid这个子进程，如果没有这个pid的退出

	竞态
		(1) 竞争状态，多进程环境下，多个进程同时抢占系统资源(内存你、CPU、IO)
		(2) 竞争状态对OS来说是危险的，此时OS如果没处理好就会造成结果不确定。

九、exec族函数
	1、为什么需要exec族函数：
		(1) fork创建子进程是为了执行新程序。
		(2) 可以写在子进程的if结构中

		(3) exec族函数运行新的可执行程序(exec函数可以直接把一个编译好的可执行程序直接加载运行)

	2、 exec族函数介绍
		(1) execl 和 execv  		这两个事最基本的exec函数，区别是传参不同

		(2) execlp 和 execvp		这两个函数较上面两个多了个p，上面必须制定可执行程序的全路径，
								而这两个可以使file(也可以是path，只不过兼容了file，加了p的这两个
								函数会首先去找file，如果找到则执行，没找到回去环境变量PATH所指定的
								目录下找，找到执行，找不到则报错)

		(3) execle 和 execvpe	相较于execl多了个e 即 environ 环境变量。
				int main(int argc, char const *argv[],char **env)

十、进程状态和system函数
	1、进程的5种状态
		(1) 就绪态	运行条件满足，就差cpu
		(2) 运行态	就绪态得到CPU进入运行态
		(3) 僵尸态	进程已经结束但是父进程还没来得及回收
		(4) 等待态	(浅度睡眠 & 深度睡眠) 进程等待资源，得到该资源就可进入就绪态。前度睡眠可以被(信号)唤醒，
					深度睡眠时不能被唤醒，只能等待条件到了才能结束睡眠状态。
		(5) 暂停态	暂停并不是进程终止，只是被人(信号)暂停了，还是可以恢复的。

	2、 进程个状态之间的转换图
	3、 system函数介绍
		(1) system = fork + exec
		(2) 原子操作：整个操作一旦开始就必须操作。 好处:不会引来竞争状态。		坏处：占用cpu时间太长。

十一、进程关系
	1、无关系
	2、父子进程关系
	3、进程组(group)		由若干进程构成一个进程组
	4、会话(session)		会话就是进程组的组

十二、守护进程的引入
	1、 进程查看命令 ps
		(1) ps -aux 偏向显示进程各种占用资源
		(2) ps -ajx 偏向显示各种有关的ID号

	2、 向进程发送信号指令 kill
		(1) kill -信号编号 进程ID
		(2) kill -9 xxx

	3、 守护进程
		(1) daemon				守护进程，简称d
		(2) 长期运行 (一般是开机运行指导关机时结束)
		(3) 与控制台脱离			普通进程都与终端相绑定，终端关闭则这个终端下的进程全部被强制关闭，背后的问题在于会话
		(4) 服务器(server)		服务器程序就是一个一直在运行的程序，给我们提供某种服务(譬如nfs服务器)

		(5) 常见的守护进程
			syslogd		: 系统日志守护进程，提供syslog功能
			cron		: cron进程用来实现操作系统时间管理，Linux中实现定时执行程序的功能就要用到cron。

		(6) 编写守护进程
			(1) 子进程等待父进程退出
			(2) 子进程使用setsid创建新的会话，脱离控制台
			(3) 调用chdir将当前工作目录设置为/
			(4) umask设置为0以取消任何文件权限屏蔽
			(5) 关闭所有文件描述符
			(6) 将0、1、2定位到/dev/null

	4、使用syslog来记录调试信息
		openlog ： 
		syslog  ： 
		closelog： 

		log信息一般都在/var/log/message这个文件中。
		Ubuntu中在：/var/log/syslog文件中。

		syslog工作原理：
			(1)操作系统有一个守护进程syslogd(开机运行，关机结束)，这个守护进程
				syslogd负责进行日志文件写入和维护。
			(2)syslogd是独立与我们任何一个进程而运行的，我们当前进程和syslogd进程本来是没有任何
				关系的，但是我们当前进程可以通过调用openlog打开一个和syslogd想链接的通道，然后通过
				syslog想syslogd发消息，然后又syslogd来将其写入日志文件中。
			(3)syslogd其实就是一个日志文件系统的服务进程，提供日志服务。任何需要些日志的进程都可以
				通过/openlog/syslog/closelog这三个函数来利用syslogd提供的日志服务。这就是操作系统
				的服务式设计。

	5、守护进程长时间运行而不退出，因此我们需要这个进程只运行一个就可以(单例运行)。
		单例运行：一个程序的进程没有运行则运行，如果运行了就直接退出。

		实现方法：用一个文件的存在与否来做标志。具体的做法就是在执行之处去判断一个特定的文件是否存在，
				若存在则标明已经运行，若不存在则标明没有运行。然后运行程序时区创建这个文件。当程序结束的
				时候去删除这个文件即可。(文件名要特殊以确保系统中不存在)


十三、进程间通信(IPC)
	1、为什么需要进程间通信
		(1) 进程间通信(IPC)指的是2个任意进程之间的通信。
		(2) 同一个进程在一个地址空间中，所以同一个进程的不同模块(不同函数、不同文件)之间比较简单(很多时候是全局变量、函数参数传递)。
		(3) 两个不同的进程处于不同的地之间空间，因此要互相通信很难。

	2、 什么样的程序需要进程间通信
		(1) 绝大部分程序都是不需要进程间通信的。因此大部分程序都是单进程的(可以多线程)
		(2) 复杂、大型的程序，因为设计的需要就必须设计成多进程程序(我们整个程序就设计成多个进程同时工作来完成的模式)，常见的如GUI、服务器。
		(3) 结论：IPC 技术一般中小型程序中用不到，在大型程序中才会用到。

	3、 Linux内核提供多种进程间通信机制
		(1) 无名管道、有名管道
				无名管道(管道)： *** 单向通信 ---> 半双工 ***
					原   理	：内核维护的一块内存，有读端和写端
					实现方法 ：父进程创建管道后fork子进程，子进程继承父进程的管道id。
					限	制	： 只能在父子进程间通信。
					函数(API)：pipe、write、read、close

				有名管道(fifo)： first in first out 先进先出   <--->   (stack 先进后出)
					原   理  ：	内核维护的一块内存，表现形式为一个文件
					使用方法  ： 固定一个文件名，2个进程分别使用mkfifo创建文件，然后分别open打开获取fd，然后一个读一个写
					限	制	 ：半双工(but 不限父子进程)
					函数API : mkfifo、open、write、read、close

		(2) SystemV IPC : 信号量、消息队列、共享内存	(内核维护的一段公共内存)
				信 号 量 ： 
					(1) 实质就是一个计数器(其实就是一个可以用来计数的变量，可以理解为ina a)
					(2) 目的：实现互斥与同步
				消息队列 ： 
					(1) 本质上是一个队列，可以理解(内核维护了一个)为FIFO
					(2) 工作时A和B 2个进程进行通信，A向队列中放入消息，B从队列中读出消息。
				共享内存 ： 
					(1) 大片内存直接映射
					(2) 类似于LCD显示时的显存用法
		(3) Socket域套接字
		(4) 信号 

十四、信号
	1、什么是信号(可以理解是一种软件中断)
		(1) 内容受限的一种异步通信机制
		(2) 目的：通信 (进程间)，内容少
		(3) 信号是异步的(对比硬件中断)
		(4) 本质上是int型数字编号(事先定义好的)
	2、常见信号介绍
		(1) 用户在终端按下按键
		(2) 硬件异常后由操作系统内核发出信号
		(3) 用户使用kill命令向其他进程发出信号
		(4) 某种软件条件满足后也会发出信号，如alarm闹钟时间到会产生SIGALARM信号，向一个读端已经关闭
			write时产生SIGPIPE信号
	3、谁处理、如何处理
		(1) 忽略信号 
		(2) 捕获信号 (信号绑定了一个函数)
		(3) 默认处理 (当前进程没有明显的管这个信号，默认：忽略 或者 终止进程)

	4、常见信号介绍
		(1) SIGINT				2			Ctrl+c时OS发送给前台进程组中每个进程
		(2) SIGABRT				6			调用abort函数，进程异常终止
		(3) SIGPOLL 	SIGIO	8			指示一个异步IO事件，在高级IO中提及
		(4) SIGKILL				9			杀死进程的终极办法
		(5) SIGSEGV				11			无效存储访问时OS发出该信号
		(6) SIGPIE 				13			设计管道和socket
		(7) SIGALARM 			14			涉及alarm函数的实现
		(8) SIGTERM				15			kill命令发送的OS默认终止信号
		(9) SIGCHLD 			17			子进程终止或停止时OS向其父进程发送此信号
		(10) 
			SIGUSR1				10			用户自定义信号，作用和意义由应用自己定义
			SIGUSR2				12			

	5、进程对信号的处理
		(1) signal 函数绑定捕获函数 即：信号处理函数
		(2) signal 返回值：信号发送后
		细节：signal函数绑定一个捕获函数后信号发生后自动执行绑定的捕获函数，并且把信号编号作为传参穿个捕获函数
			signal返回值：在出错时：SIG_ERR。		绑定成功时返回旧的捕获函数

			注：绑定捕获函数少用，移植性较差。可以用sigaction.

		sigaction函数可以设置新的捕获函数，也可以得到旧的指针函数。

	6、alarm函数
		(1) 内核只为每个进程维护一个 alarm
		(2) alarm 函数返回值为上次剩余的时间

	7、pause函数
		(1) 当前进程挂起交出cpu

十五、高级IO
	1、非阻塞IO
		阻塞：
			(1) 阻塞：当前进程调用的函数进入到内核后因为当前进程不满足而挂起
			(2) 为什么需要阻塞式
			(3) 常见的阻塞：wait、pause、sleep等函数； read、write某些文件时。
			(4) 阻塞的好处：有利于操作系统的性能发挥。

		非阻塞：
			(1) 为什么要实现非阻塞(阻塞式在多路IO时可能会出问题)
			(2) 实现 O_ONNBLOCK   fcntl

	2、阻塞式IO的困境
		(1) 程序中读取键盘
		(2) 程序中读取鼠标
		(3) 程序中同时读取键盘与鼠标
	3、并发式IO
		(1) 非阻塞式IO
		(2) 多路复用IO
		(3) 异步通知(异步IO)

	4、IO多路复用原理
		外部阻塞式、内部非阻塞式自动轮训多路阻塞式IO
		(1) select
		(2) poll 

	5、异步IO
		(1) 几乎可以认为异步IO就是操作系统用软件实现的一套中断相应系统。
		(2) 异步IO的工作方法是：我们当前进程注册一个异步IO事件(使用signal注册一个信号SIGIO的处理函数)，
			当前进程可以正常处理自己的事情，当一部事件发生后当前进程会受到一个SIGIO喜好从而执行绑定的处理函数
			去处理这个异步事件。

		(3) 涉及到的函数：
			(1) fcntl (F_GETFL、F_SETFL、O_ASYNC(指示当前fd可以接受异步通知)、F_SETOWN(设置异步通知接受进程))
			(2) signal 或者 sigaction (SIGIO)

	6、内存映射
		(1) mmap 共享而不是复制，处理大文件而非小文件

	void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);


十六、线程
	1、进程的优势：
		(1) CPU时分复用，单核心CPU可以实现宏观上的并行
		(2) 实现多任务需求(多任务的需求是客观的)
	2、进程的劣势
		(1) 进程间切换开销的
		(2) 进程间通信麻烦而且效率低

		(3) 解决方案就是线程技术
			(1) 线程技术保留了进程技术实现多任务的特性。
			(2) 线程的改进就是线程间切换和线程间通信上提升了效率
			(3) 过线程在多核心CPU上面更有优势

	3、线程的引入
		(1) 一种轻量级的进程
		(2) 线程是操作系统调度的最小单元
		(3) 一个进程可以有多个线程
	4、线程技术的优势
		(1) 像进程一样可以被OS调度
		(2) 同一个进程的多个线程之间很容易高效通信
		(3) 在多核心CPU(对称多处理器架构SMP)架构下效率最大化

	5、线程常见函数
		(1) 线程创建与回收
			(1) pthread_create		主线程用来创建子线程
			(2) pthread_join		主线程用来等待(阻塞)回收子线程
			(3) pthread_detach		主线程用来分离子线程，分离后主线程不必再去回收子线程
		
		(2) 线程取消
			(1) pthread_cancel			一般都是主线程调用该函数取消(kill)子线程
			(2) pthread_setcancelstate	子线程设置自己是否允许被取消
			(3) pthread_setcanceltype	设置子线程取消模式(立即over or wait can over)

		(3) 线程函数退出		(不能使用  exit，他会退出进程)
			(1) pthread_exit 与 return 退出

			(2) pthread_cleanup_push		子线程带锁情况下 exit ，没有ulock，这个函数可以解决这个问题
			(3) pthread_cleanup_pop

		(4) 获取线程id
			(1) pthread_self

	6、线程同步之信号量
		(1) 任务：用户从终端输入任意字符然后统计个数显示，输入end结束。

		(2) 线程同步：子线程被阻塞，主线程可以激活，这就是线程的同步
				(1) API:
						sem_init();
						sem_post();
						sem_wait();
						sem_destroy();

	7、线程同步之互斥锁 (mutex)
		(1) API:
				pthread_mutex_init();			pthread_mutex_destroy();
				pthread_mutex_lock();			pthread_mutex_unlock();
		
		(2) 互斥锁与信号量的关系		(只有 0和1 的信号量)
				互斥锁是一种特殊的信号量。

		(3) 互斥锁主要用来实现关键段的保护

	8、线程同步之条件变量  	(阻塞与等待)
		(1) API :
				pthread_cond_init		pthread_cond_destroy
				pthread_cond_wait		pthread_cond_signal(单个唤醒)/thread_cond_broadcast(唤醒全部)


十七、网络编程
	1、 基础知识
		1、
			(1) 网络通信其实就是网络中不同(相同)主机上面的2个进程之间的通信。
			(2) 网卡 --> 网卡驱动 --> API(socket接口)
			(3) 应用层：低级 		(直接基于socket接口编程)
			(4) 应用层：高级 		(基于网络通信应用框架库)
			(5) 应用层：更高级 	(http、网络控件等)

		2、学习方法
			(1) 重点1：掌握网络通信的架构层次和基本原理
			(2) 重点2：掌握socket及其相关函数的使用
			(3) 重点3：掌握服务器和客户端程序通信的方法

	2、 基础知识
		1、
			(1) 单机阶段
			(2) 局域网阶段
			(3) 广域网internet阶段
			(4) 移动互联网阶段
			(5) 物联网阶段
		2、三大网络
			(1) 电信网、电视网络、互联网
		3、网络通信的传输没接
			(1) 无线传输：WIFI、蓝牙、zigbee、4G/5G/GPRS等
			(2) 有线通信：双绞线、同轴电缆、光纤等

	3、 网络通信基础知识
		(1) OSI 7层网络模型 
					--> 物理层 数据链路层 网络层 传输层 会话层 表示层 应用层 

		(2) 网卡 (隔离与连接)
			(1) 计算机上网必备硬件设备，CPU考网卡来连接外部网络
			(2) 串转并 设备   cpu <- 并行 -> 网卡    网卡 <- 串行全双工、差分 -> 外部网络
			(3) 作用：数据帧 的封包和拆包  包头有网卡解决
			(4) 网络数据缓存和速率适配

		(3) 集线器 (广播 效率低)
			(1) 信号放大，相当于中继器
			(2) 组成局域网络，用广播方式工作
			(3) 集线器不能用来连接外网的

		(4) 交换机 (有地址映射表，可实现定向发送数据。第一次发送时找不到则广播然后就可以建立表)
			(1) 包含集线器的功能，但更高级
			(2) 交换机中有地址表，数据包查表后直达目的通信口而不是广播
			(3) 找不到目的的口时广播学习

		(5) 路由器
			(1) 路由器是局域网和外网通信的出入口
			(2) 路由器将整各internet划分成一个个的局域网，却又互相联通
			(3) 路由器对对内管理子网(局域网)，可以再路由器中设置子网的网段，设置有线端口的IP地址，
				设置dhcp功能等，因此局域网的IP地址是路由器决定的。

				WAN:路由器对外
				LAN:路由器对内

			(4) 路由器对外实现联网，联网方式取决于外部网络(如ADSL拨号上网、宽带账号、局域网等)。这时候
				路由器有相当于是更高级网络的其中一个节点而已。

			(5) 所以路由器相当于有两个网卡，一个对内做网关，一个对外做节点。
			(6) 路由器的主要功能是为经过路由器的每个数据包寻找一条最佳(路由)并转发出去。其实就是局域网内
				电脑要发送到外网的数据包，和外网回复给局域网内电脑的数据包。
			(7) 路由器技术是网络中最重要技术，决定了网络的稳定性和速度。

		(6) DNS(Domain Name Service 域名服务)
			(1) 网络世界的门牌号：IP地址
			(2) IP地址的缺点：难记、不直观
			(3) IP地址的替代产品：域名
			(4) DNS服务器就是专门提供域名和IP地址之间的转换的服务的，因此域名要购买的
			(5) 我们访问一个网站的流程是：先使用IP地址访问DNS服务器，查询我们要访问的域名的IP地址，然后
				再使用该IP地址访问我们真正要访问的网站。这个过程被浏览器封装屏蔽，其中使用的就是DNS协议。
			(6) 浏览器需要DNS服务器，而QQ这样的客户端却不要(因为QQ软件编程时已经知道了腾讯的服务器IP地址，
				因此可以直接IP方式访问服务器)

		(7) DHCP（dynamic host configuration protocl,动态主机配置协议）
			(1) 每台计算机都需要一个IP地址，且局域网内个电脑IP地址不能重复，否则会地址冲突。
			(2) 计算机的IP地址可以静态设定，也可以动态分配。
			(3) 动态分配是局域网内的DHCP服务器来协调的，很多设备都能提供DHCP功能，譬如路由器。
			(4) 动态分配的优势：为了方便接入和断开、有限的IP地址得到充分利用

		(8) NAT (network address translation 网络地址转换协议)
			(1) IP地址分为公网IP(internet 范围内唯一的IP地址)和私网IP(内网IP)
			(2) 网络通信的数据包中包含有目的地址的IP地址
			(3) 当局域网中的主机要发送数据包给外网时，路由器要负责将数据包头中的局域网主机的内网IP替换为
				当前局域网的对外外网IP。这个过程就叫NAT。
			(4) NAT的作用是缓解IPv4的IP地址不够用的问题，但只是类似于打补丁的形式，最终的解决方案还是考IPv6
			(5) NAT穿透介绍

		(9) IP地址
			(1) IP地址分类：(IPv4)
				(1) IP地址实际是一个32位的二进制构成，在网络通信数据包中就是32位的IP地址，而在人机交互中
					使用点分十进制方式显示。
				(2) IP地址中32位其实是包含两部分。分别为：网络地址和主机地址。子网掩码，用来说明网络地址和
					主机地址各占多少位。

					IP地址 = 网络地址 + 主机地址
					网络地址：表示子网	
					主机地址：表示子网中的主机硬件

					8位表示网络、24位表示主机；16 、 16 ； 

					子网掩码：255.255.255.0 ：前24位为网络地址，后8位为主机地址
						(1) 子网掩码为 255.255.255.0 时表示这个网络中可以有2^(24)个网络，每个这种网络下可以有
							2^8个主机
				(3) 有网络地址和主机地址分别占多少位的不同，将IP地址分为5类，最常用的有三类。

					(1) A类
					(2) B类
					(3) C类

					(4) 127.0.0.0用来测试回环测试 lookback

				(4) 如何判断2个IP地址是在同一个子网内
					(1) 网络标识 = IP地址 & 子网掩码
					(2) 2个IP地址的网络标识一样，那么就处于同一网络。

	4、网络编程框架
		1、
			(1) Linux网络编程框架
				(1) 网络分层 OSI 7层模型
				(2) 网络为什么要分层
				(3) 网络分层的具体表现

				2、BS CS
					CS架构介绍： (client server, 客户端服务器架构)
					BS架构介绍： (broswer server，浏览器服务器架构)
			(2) TCP/IP 协议的学习 
				1、
					(1) TCP协议工作在传输层，对上服务socket接口，对下调用IP层
					(2) TCP协议面向连接，通信前必须先3次握手建立连接关系后才能开始通信。
					(3) TCP协议提供可靠传输，不怕丢包、乱序等。

					TCP如何保证可靠传输
						(1) TCP在传输有效信息前要求通信双方必须先握手，建立连接才能通信
						(2) TCP的连接放收到数据包后会发送ack给发送方，若发送方为收到ack后 丢包重传。
						(3) TCP的有效数据内容会附带校验，以防止内容在传递过程中损坏
						(4) TCP会根据网络贷款来自动调节适配速率 (滑动窗口技术)
						(5) 发送方会给个分割报文编号，接收方会校验编号，一单顺序错误即会重传。
				2、
					(1) TCP的三次握手
						(1) 建立连接需要三次握手
								C ---    SYN  	--->  S 		SYN : 同步
								C <--- SYN+ACK  ---   S 		ACK : 回应
								C ---    ACK    --->  S
						(2) 建立连接的条件：服务器listen时客户端主动发起connect

					(2) TCP的四次握手
						(1) 服务器和客户端都可以主动发起关闭
								C --- FIN --- S 		>
								C --- ACK --- S 		<
								C --- FIN --- S 		>
								C --- ACK --- S 		<

					注：这些协议已经封装在TCP协议内部，socket编程接口平时都不用管

					(1) 基于IP地址的服务模式
						(1) 具有公网IP地址的服务器(或者使用动态IP地址映射技术)
						(2) 客户端socket、bind、listen后处于监听状态
						(3) 服务端socket后，直接connect去发起连接。
						(4) 服务器收到并同意客户端接入后会建立TCP连接，然后双方开始收发数据，
							收发时是双向的，而且双方均可发起。
						(5) 双方均可发起关闭连接。

					(2) 常见的使用了TCP协议的网络应用
						(1) http、ftp
						(2) QQ服务器 
						(3) mail服务器

			(3) socket编程接口
					(1) 建立连接 
						(1) socket  
							int socket(int domain, int type, int protocol);  
							domain:域  IPv4 还是 IPv6
							type ： 连接方式  TCP or UDP

							socket函数类似于open，用来打开一个网络连接，如果成功则返回一个网络文件描述符(int类型)
							之后我们操作这个网络连接都通过这个网络文件描述符。
						(2) bind 
							int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
							sockfd : socket 函数返回的网络连接描述符

						(3) listen 
							int listen(int sockfd, int backlog);
							backlog：表示同时可以监听个数
						(4) connect
							int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
							const struct sockaddr *addr ： 服务器IP地址



					(2) 发送和接收
						(1) send 和 write 
						(2) recv 和 read 

					(3) 辅助性函数	-->	IP地址转换  
						以下支持IPv4
						(1) inet_aton	
						(2) inet_addr	
						(3) inet_ntoa	
						以下支持IPv6   n：可以理解为网络端使用的   32位二进制
									  p：可以理解为字符串			192.168.0.0
						(4) inet_ntop	
						(5) inet_pton	

					(4) 表示IP地址相关数据结构
						(1) struct sockaddr, 这个结构体是网络编程接口中用来表示一个IP地址的，注意这个IP地址是不区分
							IPv4还是IPv6的，即：兼容IPv4 与 IPv6
						(2) typedef uint32_t in_addr_t;  网络内不用来表示IP地址的类型
						(3) struct in_addr 
							{
								in_addr_t s_addr;
							}
						(4) truct sockaddr_in
						    {
							    __SOCKADDR_COMMON (sin_);			/*地址族IPv4 IPv6*/
							    in_port_t sin_port;                 /* Port number.  */
							    struct in_addr sin_addr;            /* Internet address.  */

							    /* Pad to size of `struct sockaddr'.  */
							    unsigned char sin_zero[sizeof (struct sockaddr)
							                           - __SOCKADDR_COMMON_SIZE
							                           - sizeof (in_port_t)
							                           - sizeof (struct in_addr)];
						  	};
						 (5) struct sockaddr。		
						 		这个结构体是Linux网络编程中用来表示IP地址的标准结构体，bind、connect等函数中都需要这个结构体，
						 		这个结构体是兼容IPv4和IPv6的。	在实际编程中这个结构体会被一个struct sockaddr_in或者
						 		一个struct sockaddr_in6所填充。



		3、socket编程实践
			(1) 服务器
					(1) socket
					(2) bind
					(3) listen
					(4) accept
	
			(2) 客户端
					(1) socket 
					(2) connect

			注意：端口号，实质就是一个数字编号，用来在我们一台主机中(主机的操作系统中)位移的标识一个能上网的进程
				 端口号和IP地址一起打包到当前进程发出或者接收到的每一个数据包。每一个数据包将来在网络上传递的时候
				 ，内部都包含了发送方和接收方的信息(就是IP地址和端口号)，所以IP地址和端口号这两个往往打包在一起不分家。

		4、socket编程实践
			(1) 客户端 给 服务器
			(2) 服务器 给 客户端

		5、探讨：如何让服务器和客户端好好沟通
			(1) 客户端与服务器原则上都可以任意发和收，但实际上双方必须配合：client发的时候service就收，而service发的
				时候client就收。
			(2) 必须了解到一点：client和service之间的通信时异步的，这就是问题的根源
			(3) 解决方案：依靠应用层协议来解决。说白了就是我们service和client事先做好一系列的通信约定。

		6、socket编程实践
			(1) 自定义应用层协议第一步：规定发送和接收方法
				(1) 规定连接建立后由客户端主动向服务器发出一个请求数据包，然后服务器收到数据包后回复客户端一个回应数据包
					，这就是一个通信回合。
				(2) 整个连接的通信就是由n多个回合组成的。

