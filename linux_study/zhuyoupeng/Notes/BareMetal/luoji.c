ARM 汇编：
	一、特点
		1、 LDR/STR架构
			ldr (load register)		指令将内存内容加载入通用寄存器
			str (store register)	指令将寄存器内容存入内存空间中
		2、 8种寻址方式
			寄存器寻址			mov r1,r2
			立即寻址				mov r0,#0xFF00
			寄存器移位寻址		mov r0,r1,lsl #3		lsl 左移 --> left mov left

			寄存器间接寻址		mov r1,[r2]				[r2]  表示 r2寄存器中存着的地址上的内容，很像C语言中的 *r2 
			基址变址寻址			mov r1,[r2,#4]			[r2,#4] 表示 r2寄存器中存着的地址+4 地址中的内容
			多寄存器寻址			ldmia r1!,{r2-r7,r12}	将 r1 地址开始的连续七个地址中的内容加载到 r2 - r7 ,r12 中。r1可以看做是数组名。
			堆栈寻址				stmfd sp!,{r2-r7,r12}	类似于多寄存器寻址

			相对寻址				beq flag
							flag:

		3、 指令后缀
			B (byte)			功能不变，操作长度变为8位
			H (half word)		功能不变，长度变为16位
			S (signed)			功能不变，操作数变为有符号 (多与 B H 搭配)
				ldr ldrb ldrh ldrsb ldrsh

			S (S标志)			功能不变，影响CPSR标志位 (N Z C V标志位，movs会置相应位)
				mov movs 

		4、 条件执行后缀
			mov r0,r1 			@ 相当于C语言中的 r0 = r1
			moveq r0,r1 		@ 如果eq后缀成立，则直接执行mov r0,r1；如果eq不成立则本剧代码直接作废，相当于没有
								@ 类似于C语言中的 if (eq) {r0 = r1;}
				条件后缀执行注意2点：
					1、 条件后缀是否成立，不是取决于本剧代码，而是取决于代码之前的代码运行后的结果。
					2、 条件后缀决定了本剧代码是否执行，而不会影响上一句和下一句的执行。

		5、 多级指令流水线 (以3级为例)
			取指					解码					执行

			下下一跳执行指令		下一条执行指令		当前执行指令

			pc 中存在的事 取指 的指令

		6、 数据处理指令
			数据传输指令		mov(move) 		mov r1,r0		@两个寄存器之间数据传递
											mov r1,#0xFF00 	@将立即数赋值给寄存器 
							mvn				用法与mov一样，mov是原封不动的传递，而mvn是按位取反后传递
								例如： r1 = 0xFF 	
										mov r0,r1 	@r0 = 0xFF
										mvn r0,r1 	@r0 = 0xffffff00 

			算术指令			add		+
							sub		-
							rsb		反减 a-b --> b-a
							adc
							sbc
							rsc
			逻辑指令			and		&
							orr		|
							eor		异或
							bic		位清除指令 bic r0,r1,#01f	将r1中的数的 bit0 -- bit4清零赋值给r0

			比较指令			cmp 	cmp r0,r1 		等价于 sub r2,r0,r1  (r2 = r0 - r1)
							cmn		cmn r0,r1   	等价于 add r0,r1 
							tst		tst r0,#0x0f    测试r0 的 bit0 -- bit4 是否为0
							teq
							比较指令用来比较寄存器中的值，比较指令不用后加s后缀就可以影像cpsr标志位

			乘法指令			mvl
							mla
							umull
							umlal
							smull
							smlal
			前导零计数		clz

		7、cpsr访问指令 (spsr也可以用这来给你个指令)
			mrs 			用来读cpsr寄存器
			msr 			用来写cpsr寄存器


	1.04.5、 Makefile 
		1、 Makefile中的一些基本概念
			目标：目标定格写，后面是冒号（冒号后面是依赖）
			依赖：依赖是用来产生目标的原材料。
			命令：命令前面一定是Tab，不能是定格，也不能说多个空格。命令就是要生成那个目标需要做的动作。

		2、 Makefile的基本工作原理
			其一，当我们执行 make xx 的时候，Makefile会自动执行xx这个目标下面的命令语句。
			其二，当我们make xx的时候，是否执行命令是取决于依赖的。依赖如果成立就会执行命令，否则不执行。
			其三，我们直接执行make 和make 第一个目标  效果是一样的。（第一个目标其实就是默认目标）

		3、 进阶
			《跟我一起学Makefile》 （作者：陈浩）

	1.04.6 mkv210_image.c文件详解1
		1）mkv210_image.c使用演示
			1、 裸机程序中的Makefile（实际上真正的项目的Makefile都是这样的）是把程序的编译和连接过程分开的。（平时我们用gcc a.c -o exe 这种方式来编译时，实际上吧编译和连接过程异步完成了。在内部实际上编译和连接永远是分开独立运行的，编译	要使用编译器 gcc，连接要是用链接器 ld）。

			2、 链接器得到的led.elf 其实就是我们的可执行程序，（如果实在操作系统下，这个led.elf就可以执行了）但是在嵌入式裸机中我们需要的事可以烧写的文件（可少些的文件就叫镜像 image），因此我们需要用这个 led.elf 为原料来制作镜像。制作工具是较差编译工具链中的 arm-linux-objcopy 

			3、 我们是用 arm-linux-objdump 工具进行反编译（反汇编），反汇编其实就是把编译后的elf格式可执行程序给反过来的到对应的汇编程序。得到他的汇编源代码。我们是用反汇编主要是用来学习。后续会详解。

			4、 mkv210_image.c 这个程序其实最终不是在开发板上执行的，而是在Linux（就是用来执行make对整个项目进行编译的那个机器）中执行的，因此编译这个程序用gcc而不是 arm-linux-gcc。这个 .c 文件编译后得到一个可执行程序 xxx，目的是通过这个 xxx 程序而由 led.bin（usb启动的文件） 得到 210.bin （通过sd启动裸机的镜像）。加工的具体方法见 mkv210_image.c。

		2）Makefile中 $@ 代表目标，$< 代表依赖， -c 表示只编译不连接，-o表示其后为输出文件名。 -Ttext 0x0 表示连接基地址为 0.
	1.04.6.2、 背景知识：S5PV210的启动过程回顾
		1、 分析启动过程可知：210启动后先执行内部 iROM 中的 BL0，BL0执行完后会根据OMpin的配置选择一个外部设备启动（有很多，我们实际使用的有2个：usb启动和SD卡启动）。在usb启动时内部BL0读取到 BL1 不做校验，直接从BL1的是指内部 0xd0020010 开始执行，因此usb启动的镜像led.bin 不需要头信息，因此我们从usb 启动时直接将镜像下载到 0xd0020010 去执行即可，不管头信息了；从sd卡启动时，BL0 会读取 sd卡 得到完整的镜像（led.bin + 16字节的头），然后BL0会自己根据实际镜像（led.bin）的校验和checksum与头信息中的checksum比对，正确则执行否则失败（会转入执行 2st 启动，即SD2启动。如果这里已经是 2st 启动了，这里校验不通过就死定了）。

		2、 mkv210_image.c 的作用； 为 BL1 添加校验头。
			我们编译时只得到led.bin，这个210.bin得到的交叉编译工具链完全无关。有 led.bin 得到 210.bin 的过程是厂家芯片所特有的，因此需要我们自己去完成，为此有了 mkv210_image.c。

		3、 整个程序工作流分析
			首先申请一个 16KB 大小的buffer，然后把所有内容按照各自的位置填充进去，最终填充好的 buffer 写入到一个文件（210.bin）就形成了我们想要的镜像。

	1.04.6.3 mkv210_image.c文件详
		1、 代码详解

		2、 main函数的2个形参 argc、argv。
			argc：参数个数
			argv：字符串数组

		3、 glibc中读写文件接口
			fopen
			fseek
			fread
			fwrite
			fclose

		4、 校验和的计算方法
			for(i = 0, checksum = 0; i < IMG_SIZE - SPL_HEADER_SIZE; i++)
				checksum += (0x000000FF) & *a++;

	1.04.8 一步步点亮LED1 硬件工作原理及原理图查询
		1.4.8.1 LED物理特性介绍
			1、 LED本身有两个界线点， 正极、负极。 

		1.4.8.2 查阅原理图了解板载这颗LED硬件接法

		1.4.8.3 分析如何点亮及熄灭LED （GPIO）

	1.4.9 一步步点亮LED 数据手册查询及相关寄存器浏览
		1.4.9.1 GPIO 概念的引入
			1、 GPIO : general purpose input output 通用输入输出

			2、 GPIO 就是芯片的引脚（芯片上的引脚有些不是GPIO，只有一部分是），作为GPIO的这类引脚，他的功能和特性点事可以被编程控它的工作模式，也可以编程控制他的电压高低等。

		1.4.9.2 阅读数据手册中有关部分
			1、 当我们想要通过编程操控GPIO来操作LED时，我们首先需要通读一下 S5PV210 的数据手册有关 GPIO 部分。

		1.4.9.3 GPIO 相关的寄存器介绍
			1、 软件操作硬件的接口是：寄存器
			2、 led <-- GPIO <-- 寄存器 
			3、 查询数据手册可知 GPJ0 的寄存器有 ： 
				GPJ0CON： 		(GPI0 control) GPJ0控制寄存器,用来配置各引脚的工作模式
				GPJ0DAT：		(GPIO data)	当引脚配置为input/output模式时，寄存器的相应位和引脚的电平高低相对应。
				GPJ0PUD：  		(pull up down) 控制引脚内部弱上拉、下拉
				GPJ0DRV：		(driver) 配置GPIO的驱动能力
				GPJ0CONPDN： 	()
				GPJ0PUDPDN：

				注：驱动LED，将模式裴志伟输出模式

				如何点亮LED ,编程的步骤：
					1、 操控 GPJ0CON ,选择输出模式
					2、 操控 GPJ0DAT ，设置 0/1
			4、 实际真正操作LED的硬件寄存器，主要有：GPJ0CON, GPJ0DAT

		1.4.9.4 一步步点亮LED3 从零开始手写汇编代码
			1.4.9.4.1、 GPxCON、GPxDAT寄存器分析
				1、 GPJ0端口一共有8个引脚，分别记做：GPJ0 -- GPJ7，相关重要寄存器就是 GPJ0CON、GPJ0DAT
				2、 GPJ0CON寄存器中设置8个引脚的工作模式（32/8=4，每个引脚分到 4 位，譬如：GPJ0_0 对应的bit位为 0-3，GPJ0_3 对应的bit位为：12-15。工作方法是：给相应的寄存器位写入相应的值，该引脚硬件就会按照响应的模式去工作。譬如：给bit12-bit15写入 0b0001，GPJ0_3硬件就成为输出模式了）
			1.4.9.4.2、 从零开始写代码操作寄存器
				需要哪些先决条件才能写呢？
					1、 硬件接法和引脚 GPJ0_3、GPJ0_4、GPJ0_5 低电平亮/高电平灭
					2、 GPJ0CON : 0xE020_0240
					   GPJ0DAT:	0xE020_0244
					3、 工程管理：Makefile、脚本

					根据上述分析，实际操作：把相应的配置写入相应寄存器即可。

			1.4.9.4.3 编译、下载、运行看结果
			
		1.4.11 汇编实现延时
			1、 用一些没目的的代码占据时间，达到延时效果。
			2、 用一个寄存器存放一个数字，然后在循环中每个循环里给数字减1，然后再判断与某个数字是否相等。

反汇编工具 arm-linux-objdump
	1）反汇编的原理 & 为什么要反汇编
		1、 arm-linux-objdump -D led.elf > led_elf.dis

		2、 objdump 是 gcc工具链中的反汇编工具，作用是由编译廉洁好的 elf 格式的可执行程序反过来得到汇编代码  -D 表示反汇编   > 左边的事 elf 的可执行程序（反汇编时的原材料）， > 右边的是反汇编生成的反汇编程序。

		3、 反汇编的原因：
			1、 逆向破解	（歪门邪道）
			2、 调试程序时，反汇编程序可以帮我们理解程序。	（我们的主要目的），尤其是在理解连接脚本、链接地址等概念时。
			3、 把C语言源代码编译链接生成的可执行程序反汇编后得到对应的汇编代码，可以帮我们理解C语言和汇编语言之间的对应关系。非常有助于生如理解C语言。

	2）反汇编文件的格式和看法
			汇编：assembly
			反汇编：dissembly

			1、标号地址、标号的名字、指令的地址、指令的机器码反汇编得到的指令

			扩展：ARM汇编中用地址池方式来实现非法立即数

			2、 初始指令地址
				下载烧录执行的 bin 文件，内部其实是一条一跳的指令机器码。这些指令每一条都有一个指令地址，这个地址是链接的时候 ld 给指定的（ld根据我们写的链接脚本来指定）

			3、 展望：反汇编工具帮助我们分析链接脚本
				反汇编的时候得到的指令地址是链接器考虑了链接脚本之后得到的地址，而我们写代码时通过指定链接脚本来让链接器给我们连接合适的地址。

				但是有时候我们写的连接脚本有误（或者我们不知道这个链接脚本会怎么样），这时候可以通过看反汇编文件来分析这个链接脚本的效果，看是不是我们想要的，如果不是可以改了再看。


1.5.1 汇编写启动代码之关看门狗
	1）什么是看门狗？
		watch dog timer 看门狗定时器。实际上由于外部原因经常会导致电子设备跑飞，所以需要看门狗自动复位。看门狗其实使我们SoC内部的一个定时器。

		系统正常工作时，系统软件会自己去喂狗，所以看门狗定时器不会复位。但是系统一但故障跑飞，看你们够就没有人喂了，然后下一个周期救护自动复位，达到我们预期的效果。

	2）分析硬件物理特性、原理图、数据手册
		物理特性：定时器
		原理图：内部外设，没有外部相关的原件与他相关，所以不需要。
		数据手册：系统定时器部分

	3）找到关键性操作 SFR （特殊功能寄存器）
		WTCON（0xE2700000），其中 bit5 是看门狗的开关。

	4）编写汇编代码

	5）为什么要关闭看门狗？
		一般CPU设计，在CPU启动后看门狗默认是工作的（为什么默认不关闭而要工作？猜测：怕程序在启动前端就死机了或者跑废了没人管），好处是没有空挡和漏铜，坏处是在启动代码段我们不方便去喂狗（或者是懒得去喂狗）时看门狗恢复为，所以为了偷懒我们就在启动代码前端先去关闭看门狗，然后在后面系统启动起来之后再根据需要决定是否要打开看门狗（一但打开就必须同时提供喂狗）。


1.5.2 汇编写启动代码之设置栈和调用C语言
	1）C语言运行时需要和栈的意义
		C语言运行时（runtime）需要一定的条件，这些条件由汇编来提供。C语言运行时主要是需要栈。

		C语言与栈的关系：C语言中的局部变量都是用栈来实现的。如果我们汇编部分没有给从部分预先设置合理合法的站地址，那么C代码中定义的局部边浪就会落空，整个程序就会撕掉了。

		单片机程序或者编写应用程序时并没有去设置栈，但是程序还是可以运行的。
		原因：在单片机中由硬件初始化时提供了一个默认可用的栈，在应用程序中我们编写的C程序其实并不是全部，编译器（gcc）在连接的时候会帮我们自动添加一个头，这个头就是一段引导我们的程序能够执行的一段汇编实现的代码，这个代码中就帮我们的C程序设置了栈及其他运行时需要。

	2）CPU模式和各种模式下的栈	
		1、 在ARM中37个寄存器中，每种模式下都有自己独立的 SP 寄存器（r13），为什么这么设计？
			如果说各种模式都是用同一个 SP ，那么就意味着整个程序（操作系统内核程序、用户自己编写的应用程序）都是用一个栈的。你的应用程序如果一旦出错（譬如栈溢出），就会连累操作系统的栈也损坏了，整个操作系统的程序就会崩溃。这样的操作胸膛设计时非常脆弱的，不合理。

			解决方案就是一个钟模式下用不同的栈。我的操作系统内核使用自己的栈，每个应用程序也是用自己独立的栈，这样各是各的，一个损坏不会连累其他人。

			我们现在要设置栈，不可能也懒得而且也没必要去设置所有栈，我们先要找到自己的模式，然后设置自己的莫斯下的栈道合理合法的位置即可。

			注意：系统在复位后默认是进入 SVC 模式的。

			我们如何设置SVC 模式下的SP呢？ 
				很简单，先把模式设置为SVC，在直接操作SP。但是系统复位后就已经是SVC模式了，所以直接设置SP即可。


	3）查阅文档并设置栈指针至合法位置
		1、 站必须是当前一段可用的内存（可用的意思是这个地方必须又被初始化过可以被访问的内存，而且这个内存只会被我们用作栈，不会被其他程序征用）当前CPU刚复位（刚启动），外部的DRAM尚未初始化，目前可用的内存只有内部SRAM（因为它不需要初始化即可使用）。因此我们只能在SRAM中找一段内存来作为SVC的栈。

		2、 栈有四种：满减栈、满增栈、空减栈、空增栈
			满栈：进栈：先移动指针在存。	出栈：先出数据在移动指针
			空栈：xxx
			减栈：进栈：指针向下移动；		出栈：指针向上移动
			增栈：xxx

			ARM中，ATPCS（ARM关于程序应该怎么实现的一个规范）要求使用满减栈，所以不出意外都是用满减栈。

		结合 S5PV210_iROM_ApplicationNote_Preliminary_20091126 可知。
		栈地址：0xD0037D80

	4）汇编程序和C程序相互调用
		bl cfunction

1.5.3 写启动代码之开iCache
	1）C函数的编写和被汇编调用
		1、 在工程中新建并添加一个C语言文件（stack.c），注意添加是要修改Makefile
		2、 在汇编启动代码中设置好栈后，使用 bl xxx 的方式来调用初中的函数 xxx。

	2）使用C语言来访问寄存器的语法
		1、 寄存器的地址类似于内存地址（IO与内存统一编址的），所以这里的问题是C语言读写寄存器，就是用C语言来读写内存地址。用C语言来访问内存，就是用到指针。


	3）神奇的 volatile
		让编译器在编译时不对程序做优化。优化有时候是ok的，但是有时候是自作聪明会造成不对。如果你的一个变量时易变，不希望编译器帮我们做优化，就在这个变量定义时加volatile。

		加不加有没有茶杯，取决于编译器。如果编译器做了优化则有差异；如果编译器本身没做优化，那就没有差别。

		
	4） 总结
		1、 C和汇编函数的相互调用（函数名和汇编标号的真实意义）
		2、 C语法对内存访问的封装方式（使用指针来访问内存的技巧）
		3、 汇编的意义（其实代码 & 效率的关键部位）

	5）error info  ： stack.o:(.ARM.exidx+0x0): undefined reference to `__aeabi_unwind_cpp_pr1`

		解决方法：去百度或者谷歌解决。 
		解决办法：编译时添加 -nostdlib 这个编译选项即可解决。 nostdlib 就是不适用标准函数库。

1.5.4.1 汇编写启动代码之开iCache
	1）什么是Cache，有什么用
		1、 cache是一种内存，较高速缓存。
		2、 速度		CPU > 寄存器 > Cache > ddr
		3、 容量		CPU < 寄存器 < Cache < ddr 
				Cache 的存在，是因为寄存器和ddr之间速度差异太大，ddr的速度不能满足寄存器的需要（不能满足CPU的需要，所以没有Cache会拉低整个系统的整体速度）。整个系统中CPU的供应链由：寄存器 + cache + ddr +硬盘/flash 四阶组成，这是综合考虑了性能、成本得到的妥协的结果。
		4、 210 有 32KB 的icache，32KB的dcache，icache是指令缓存，dcache是数据缓存。

		5、 cache的意义：指令平时放在硬盘/flagsh中的，运行时读取到DDR中，再从DDR中读给寄存器，再有寄存器送给CPU。但是DDR的速度和寄存器（代表的就是CPU）相差太大，如果CPU运行完一句再去DDR读取下一句，那么CPU的速度完全被DDR拖慢了。解决方案就是icache。

		6、 icache工作时，会把CPU正在运行的指令的旁边几句指令事先读取到icache中（CPU设计有一个基本原理：代码执行时，下一句执行当前一句代码旁边代码的可能性要大很多）。低昂下一句CPU要质量时，cache首先检查自己事先准备的缓存指令中有没有这句，如果有就直接拿给CPU，如果没有则需要从DDR中重新去读取拿给CPU，并同时做一系列的动作：清缓存、重新缓存

	2）iROM中BL0对cache的操作
		1、 首先icache的一切动作都是自动的，不许认为干预。我们所需要做的就是打开/关闭icache。

		2、 在210的IROM中BL0已经打开了icache。所以之前看到的现象都是icache打开时的现象。

	3）汇编代码读写cp15已开罐cache

1.5.4 重定位引入和连接脚本1
	1）一个事实：大部分指令是位置有关编码
		1、 位置无关编码：汇编源文件被编码成二进制可执行程序时编码方式与位置（内存地址）无关。
		2、 位置有关编码：汇编源码编码成二进制可执行程序后和内存地址是有关的。

		3、 我们在设计一个程序时会给这个程序制定一各运行地址（链接地址）。我们在编译程序时其实心里是知道我们程序将来被运行时的地址的，而且必须给编译器链接器制定地址才行。最后得到的二进制程序理论上是和你指定的运行地址（运行地址）有关的，将来这个程序被执行时必须放在当时编译连接时给定的那个地址（链接地址）下才行，否则不能运行（这就叫位置有关代码）。但是有个别特别的指令他可以跟指定的地址没有关系，也就是说这些代码实际运行时不管放在那里都能正常运行。

	2）链接地址和运行地址：可能相同也可能不同
		1、 对于位置有关代码来说：最终执行时的运行地址和编译链接时给定的链接地址必须相同，否则一定出错。
		2、 之前裸机程序中 Makefile 用 -Ttext 0x0 来指定链接地址时 0x0。这一位置这个程序将来会放在0x0这个地址去运行。但是实际上程序运行时的地址是 0d0020010 （用dnw下载时指定的下载地址）。这个地址看似不同，但是实际上是相同的。这是因为S5PV210内部做了映射，吧SRAM映射到了 0x0地址去。

		3、 分清两个概念：
			链接地址：连接时指定的地址（指定方式：Makefile 中用 -Ttext，或者链接脚本）
			运行地址：程序实际运行时的地址（指定方式：由实际运行时被加载到内存的那个位置说了算）。

			对比：位置无关代码要好一些，适应性强，放在那里都能正常运行；位置有关代码就必须运行在链接时制定的地址上，适应性差。位置无关代码有一些限制，不能完成所有功能，有时候不得不使用位置有关代码。

	3）再解S5PV210的启动过程：三星推荐和uboot的实现是不同的
		1、 三星推荐的启动方式中：bootloader必须小于 96KB并大于16KB，嘉定bootloader为 80KB,启动过程是这样子：先开机上电后 BL0运行，BL0会加载外部启动设备中的bootloader的前16KB（BL1）到SRAM中去运行，BL1运行时会加载BL2（bootloader总 80-16=64KB）到SRAM中（从SRAM的16KB处开始）去运行；BL2运行时会初始化DDR并且将OS搬运到DDR去执行OS，启动完成。
		2、 uboot实际使用的方式：uboot大小随意，假定200KB。启动过程是这样的：先开机上电后 BL0运行，BL0会加载外部启动设备中的uboot的前16KB（BL1）到SRAM中去运行，BL1运行时会初始化DDR，然后会将整个uboot搬运到DDR中，然后用一句长跳转指令从SRAM中直接跳转到DDR中继续执行uboot知道完全启动。uboot启动后在uboot的命令行中去启动OS。

	4）为什么要重定位？
		1、 链接地址和运行地址有时候必须不同，而且还不能全部用位置无关码，这时候只能重定位。

		扩展：分散加载。吧uboot分成两部分（BL1和uboot），两部分分别制定不同的链接地址。启动时将两部分加载到不同的地址（BL1加载到SRAM，整个uboot加载到DDR），这时候不用重定位。

		分散加载其实相当于手工重定位。重定位时用代码来进行重定位，分散加载是手工重定位的。

1.5.5 重定位引入和连接脚本2
	1）运行时地址由什么决定？
		1、 运行时地址由运行时决定（编译链接时无法绝对确定运行地址的）

	2）链接地址由什么决定？
		1、 链接地址由程序员在编译链接的过程中，通过Makefile中-Ttext xxx 或者在链接脚本中指定的。程序员事先会预置自己的程序的执行要求，并且有一个期望的执行地址，并且会用这个地址来做连接地址。

		举例：
			1、Linux中的应用程序。 gcc hello.c -o hello，这时候使用默认的链接地址就是0x00，所以应用程序都是连接在0地址的。因为应用程序运行在操作系统的一个进程中，在这个进程中这个应用程序独享4G的虚拟地址空间。所以应用程序都可以连接到0地址，因为每个进程都是从0地址开始的。（编译时可以不给定链接地址而都使用0）
			2、 裸机程序。运行地址由下载时确定，下载时下载到 0xd0020010 ，所以就从这里开始运行。（这个下载地址也不是随意定的，是iROM中的BL0加载BL1时实现指定好的地址，这是由CPU的设计决定的）。所以理论上我们编译连接时应该将地址指定到 0xd0020010 ，但是实际上我们在之前裸机程序中都是使用位置无关码PIC，所以链接地址可以使0。

	3）从源码到可执行程序的步骤：预编译、编译、连接、strip
		预编译：预编译器执行。譬如C中的宏定义就是由预编译器处理、注释、#include <> 等也是有预编译器处理的。
		编译：  编译器来执行。把源码.c .s 编成机器码 .o 文件。 
		连接：  连接器来执行。把 .o 文件中的个函数（段）按照一定规则（连接脚本来指定）累计在一起，形成可执行文件。

		strip：strip是吧可执行程序中的符号信息给拿掉，以节省空间。
		objcopy：由可执行程序生成可烧录的镜像bin文件。

	4）程序段的概念：代码段、数据段、bss段(ZI段)、自定义段
		1、 段就是程序的一部分，我们把整个程序分成了一个一个的段，给每个段七个名字，然后在连接时就可以用这个名字来指示这些段。也就是说个段命名就是为了在链接脚本中用段名来让段站在合适的位置。

		段名分为两种：一种是编译器连接器内部定好的，先天性的名字；一种是程序员自己指定的、自定义的段名。
			先天性段名：
				代码段：（.text），又叫文本段，代码段其实就是函数编译后生成的东西。
				数据段：（.data），数据单就是C语言中显示初始化为非0的全局变量。
				bss段：（.bss），又叫ZI（zero initial）段，就是零初始化段，对应C语言中初始化为0的全局变量。

			后天性段名：
				段名有程序员自己定义，短的属性和特征也由程序员自己定义。

		2、 分析一些问题，遇着例结合，试图明白一些本质。
			1、 C语言中全局变量如果未显示初始化，值就是0。 --> bss段
			2、 C运行时环境如何保证显示初始化为非0的全局变量的值在main之前就被赋值了？就是因为它把这类变量放在了 .data段中，而 .data段会在main执行之前被处理（初始化）。

	5）连接脚本究竟要做什么？
		1、 连接脚本其实是个规则文件，它是程序员用来指挥链接器工作。链接器会参考连接脚本，并且使用其中规定的规则来处理 .o 文件中那些段，将其连接成一个可执行程序。

			连接脚本的关键内容：段名 + 地址（作为链接地址的内存地址）。
			连接脚本的理解：
				SECTIONS {} 这个是整个连接脚本
				. 点号在连接脚本中代表当前位置。
				= 等号代表赋值
1.5.8 代码重定位实战
	1）任务：在SRAM中将代码从 0xd0020010 重定位到 0xd0024000 
		1、 任务解释：本来代码是运行在 0xd0020010 的，但是因为一些原因我们有希望代码实际是在 0xd0024000 位置运行的。这时候就需要重定位了。

		注解：本练习对代码运行五十几意义，我们做这个重定位纯粹是为了练习重定位技能。但是某些情况重定位就是必须的，譬如在uboot中。

	2）思路：
		1、 通过连接脚本将代码连接到 0xd0024000
		2、 dnw下载时将 bin 文件下载到 0xd0020010

		以上两点，就保证了：代码实际下载运行在 0xd0020010，但是却被连接在 0xd0024000。从而为重定位奠定了基础。
		当把代码链接地址设置为 0xd0024000 时，实际隐含意思就是这个代码将来必须放在 0xd0024000 位置才能正确执行。如果实际运行地址不是这个地址就要出事了（除非代码是 PIC 位置无关代码），当医生都明白了，就知道重定位代码的作用就是：在 PIC 执行完之前（在代码中第一句位置有关码执行之前），必须将整个代码搬移到 0xd0024000 位置去执行，这就是重定位。

		3、 代码执行时通过代码前段的少量位置无关代码将整个代码搬移到 0xd0024000
		4、 使用一个长跳转到 0xd0024000 处的代码继续执行，重定位完成

		长跳转：首先这句代码是一句跳转指令（ARM中的跳转指令就是分支指令B、BL等作用指令），跳转指令通过给PC（r15）赋一个新值来完成代码段的跳转执行。长跳转指令的是跳转到的地址和当前地址差异较大，跳转的返回比较宽广。
		当我们执行完代码重定位后，实际上在SRAM中有2分代码的镜像（一份使我们下载到 0xd0020010 处开头的，另一份是重定位代码赋值到 0xd0024000 处开头的），这两份内容完全相同。重定位时候使用 ldr pc, =led_blink 这句长跳转直接从 0xd0020010 处代码跳转到 0xd0024000 开通处的那一份代码的led_blink函数处去执行。（实际上此时在SRAM中有2个led_blink函数镜像，两个都能执行，如果段跳转 bl led_blink则执行的是 0xd0020010 开头的这一份，如果长跳转 ldr pc, =led_blink则执行的是 0xd0024000 开头的这一份）。这就是段跳转和长跳转的区别。

		当链接地址和运行地址相同时，段跳转和长跳转实际效果是一样的；但是当链接地址不等于运行地址时，段跳转和长跳转就有差异了。这时候短跳转实际执行的是运行地址处的那一份，而长跳转执行的是链接地址处那一份。

		总结：重定位实际就是在运行地址处执行一段位置无关码PIC，让这段PIC（也就是重定位代码）从定位地址处把整个程序镜像拷贝了一份到连接地址处，完了之后使用一句长跳转指令从运行地址处直接跳转到连接地址处去执行同一个函数（led_blink），这样就实现了重定位之后的无缝连接。

1.5.9 代码重定位实战2
	1）adr与ldr伪指令的区别
		1、 ldr 和 adr 斗志伪指令，区别是 ldr 是长加载、adr 是短加载。

			重点：adr 指令加载符号地址，加载的是运行时地址；ldr 指令在加载符号地址时，加载的是连接地址。

			深入分析：只要知道 adr 和 ldr 分别用于加载运行地址和链接地址，从未可以判断是否需要重定位即可；根本不需要知道为什么 adr 和 ldr 是这样子，但是我们还是需要扩展讲下为什么加载的是不同的地址。adr 会被替换为 sub，ldr 会被替换为 ldr。

	2）重定位（代码拷贝）
		1、 重定位就是汇编代码中的 copy_loop 函数，代码的作用就是使用循环结构来逐句复制代码到链接地址。复制的原地址是 SRAM 的 0xd0020010，复制目标地址是 SRAM 的0xd0024000，复制的长度是整个代码的长度。复制长度是 bss_start - _start 所以复制的长度就是整个重定位需要重定位的长度，也就是整个程序中代码段 + 数据段的长度。

			bss段（bss段中就是0，初始化为0的全局变量）不需要重定位。

	3）清bss段
		1、 清除bss段是C语言的运行要求（C语言要求是显示初始化0的全局变量，或者未显示初始化的全局变量的值为0，实际上C语言编译器就是通过清bss段来实现C语言的这个特性的）。一般情况下我们的程序时不需要负责清除bss段的（C语言编译器和链接器会帮我们的程序自动添加一段头程序，这段程序会在我们的main函数之前运行，这段代码就负责清除bss）。但是在我们代码重定位之后，因为编译器帮我们附加的代码只是帮我们清除了运行地址那一份代码中的bss，而未清除重定位地址处开头的那一份代码的bss，所以重定位之后需要自己清除bss。

	4）长跳转
		清理完 bss 段后重定位就结束了。然后当前的状况是：
			1、 当前运行地址还是 0xd0020010 开头的（重定位前的）那一份代码中运行着。
			2、 此时 SRAM 中已经有了 2 分代码，1份在 0xd0020010 开头，另一份在 0xd0024000 开头的位置。
		然后就要长跳转了。

		ldr 加载时如果目标寄存器是 pc 就叫长跳转，如果目标是 r1等就叫长加载。

1.5.9 SDRAM引入
	1）SDRAM：Syncronized Dynamic Ramdam Access Memory,同步动态随机存储器
	   DDR：DDR就是 DDR SDRAM，是SDRAM的升级版，（DDR : double rate， 双倍速度的SDRAM）
	   DDR有好多代： DDR1 DDR2 DDR3 DDR4 DDR5 LPDDR 都需要初始化
	   SDRAM 不需要初始化 ？

	2）SDRAM的特性（容量大、价格低、掉电易失性、随机读写、总线式访问）
		SDRAM/DDR 都属于动态内存（相对于静态内存SRAM），都需要先运行一段初始化代码来初始化才能使用，不像SRAM开机上电后就可以直接运行。

		类似于 SDRAM 和 SRAM的区别的，还有 NorFlash 和 NandFlash（硬盘）这两个。

		正是因为硬件本身特性有限制，所以才导致启动代码比较怪异、比较复杂。而我们研究裸机是为了研究 uboot，在uboot中就充分利用了硬件的各种特性，处理了硬件复杂性。

	3）SDRAM数据手册带读
		SDRAM 在系统中属于SoC外设（外部外设。随着半导体发展，很多东西都逐渐集成到SoC内部去了。现在长期在外部的一般有：Flash、SDRAM/DDR、网卡芯片DM9000、音频Codec。现在有一些高度集成的芯片也试图把这几个集成进去，做成真正的单芯片解决方案。）

		SDRAM通过地址总线和数据总线接口（总线接口）与SoC通信。

		开发板原理图上使用的是 K4T1G164QQ，但实际开发板上贴的不是这个，是另一款。但是这两款是完全兼容的，进行软件编程分析的时候完全可以参考K4T1G164QQ的文档。

		全球做SDRAM的厂商不多，二线厂家做的产品参数都是向一线厂家（三星、KingSton）看齐，目的都是兼容一线厂家的设计，然后让在意成本的厂商选择它的内存芯片替代一线厂家的内存芯片。SDRAM的这个市场特征导致这个东西比较标准化，大部分时候细节参数官方（芯片原厂家）都会给你一个参考值。

1.5.11 SDRAM初始化
	1）原理图中SDRAM相关部分
		1、 S5PV210共有2个内存端口（就好像有2个内存插槽）。再结合查阅数据手册内存映射部分，可知：两个内存端口分别叫DRAM0、DRAM1:
			DRAM0：内存地址范围：0x20000000 -- 0x3FFFFFFF (512MB)，对应的引脚是 Xm1xxx
			DRAM1：内存地址范围：0x40000000 -- 0x7FFFFFFF (1024MB),对应引脚是 Xm2xxx

		2、 结论：真个210最多支持内存为 1.5G，如果给210更多的内存CPU就无法识别。

		3、 210最多支持 1.5G 内存，但是实际开发板不一定要这么多，譬如我们X210开发板就只有512MB内存，连接方法是在DRAM0端口分布256MB，DRAM1端口分布了256MB。

		4、 由以上可知，X210开发板上内存合法地址是：0x200000000 -- 0x2FFFFFFF (256MB) + 0x40000000 -- 0x4FFFFFFF (256MB)。挡板子上DDR初始化完成之后，这些地址都是可以使用的；如果使用了其他地址譬如 0x30004000 就是死路一条。

		5、 原理图中DDR端口都由3类总线构成：地址总线（Xmn_ADDR0 ~ Xmn_ADDR13共14根地址总线） + 控制总线（中间部分） +  数据总线（Xmn_DATA0 ~ Xmn_DATA31共32根数据总线）

		分析：从数据总线的位数可以看出，我们用的事32位的（物理）内存。
		原理图中画出4片内存芯片的一页，可以看出：X210开发板共使用了4片内存（每篇1Gb = 128MB,共512MB），每篇内存的数据总线都是16位的（单芯片是16位内存）。如何由16位内存得到32位内存？可以使用并联方法。在原理图上横向的2棵内存闲篇就是并联连接的。并联时地址总线接法一样，但是数据总线要假期阿里。这样连接相当于在逻辑上可以吧这2颗内存芯片看成是一个（这一个芯片是32位的，接在Xm1端口上）。

	2）数据手册中SDRAM相关部分
		1、 看数据手册《NT5TU64M16GG-DDR2-1G-G-R18-Consumer》 第10页 block diagram。这个框图是 128Bb*8结构的，这里的8指的是 8bank，每bank128Mbit。
		2、 210 的DDR端口信号中有BA0~BA2,接在内存芯片的BA0~BA2上，这些引脚就是用来选择bank的。每个bank内部有128Mb，通过row address（14位） + column address（10位）的方式来综合寻址。 一共能寻址的方位是：2^14 * 2^10 = 2^24。对应16MB（128Mb）内存。

1.5.12 汇编初始化SDRAM详解1
	1）初始化代码框架介绍（函数调用和返回、步骤等）
		1、 SDRAM初始化使用一个函数 sdram_asm_init,函数在sdram_init.S文件中实现，是一个汇编函数。
		2、 强调：汇编实现的函数在返回时需要明确使用返回指令（mov pc, lr）

	2）27步初始化DDR2
		1、 DDR初始化和SoC（准确说是和SoC中的DDR控制器）有关，也和开发板使用的DDR芯片有关，和开发板设计时DDR的连接方式也有关。
		2、 S5PV210的DDR初始化步骤在数据手册 1.2.1.3 DDR2。可知初始化DDR工序27个步骤。
		3、 之前分析过X210的内存连接凡是是：在DRAM0上连接256MB，在DRAM1上连接256MB。所以初始化DRAM时分为2部分，第一部分初始化DRAM0，第二部分初始化DRAM1。
		4、 代码参考了九鼎官方的uboot中：第二，参考了九鼎的裸机教程中对DDR的初始化；第三部分，有些参数时老朱根据自己理解修改过的。

	3）设置IO端口驱动强度
		1、 因为DDR芯片和S5PV210之间是通过很多总线连接的，总线的物理表现就是很多引脚，也就是说DDR芯片和S5PV210芯片是通过一些引脚连接。DDR芯片工作时需要一定的驱动信号，这个驱动信号需要一定的电平水平才能抗干扰，所以需要设置这些引脚的驱动能力，使DDR正常工作。

		2、DRAM控制器对应的引脚设置为驱动强度 2X （为什么需要问DDR芯片厂商，一般参考原厂给的代码）

	4）DRAM port 时钟设置
		1、 从 128 -- 154 行。主要是开启DLL（dram pll）然后等待锁存。对应27步中的第2步到第4步。

1.5.12 汇编初始化SDRAM详解1
	1）DMC0_MEMCONTROL
		burst length = 4， lchip, ...... 对应值是 0x00202400

	2） DMC0_MEMCONFIG_0
		DRAM0通道中memory chip0的参数设置寄存器。

	3）DMC0_MEMCONFIG_1
		DRAM0通道中memory chip1的参数设置寄存器。

	三星设置DRAM0通道，允许接2片256MB的内存，分别叫 memory chip0 和 memory chip1，分别用这两个寄存器来设置它的参数。按照三星的设计，chip0的地址应该是 0x20000000 到 0x2FFFFFFF，但是我们X210开发板实际在DRAM0端口只接了256MB的内存，所以只用了chip0，没用chip1，（我们虽然是2片芯片，然后这两篇是并联形成 32 为内存，逻辑上只能算 1 片）。按照这个推论，DMC0_MEMCONFIG_0有用，而DMC0_MEMCONFIG_1无用，所以直接给了默认值。

	4）DMC_DRECTCMD
		这个寄存器是个命令寄存器，210通过想这个寄存器写值来向DDR芯片发送命令（通过命令总线），这些命令都是用来配置DDR芯片工作的。

	总结：DDR配置过程比较复杂，基本上是按照DDR控制器的时序要求来做的，其中很多参数结合DDR芯片本身的参数来定，还有些参数是时序参数，要去详细计算。所以DDR配置非常繁琐、细致、专业。所以我们对DDR初始化的态度就是：学会思路和方法，结合文档和代码能看懂，会算一些常见参数即可。

	5）重定位代码到DDR中
		1、 DRAM初始化之后，实际上重定位代码过程和之前重定位到SRAM中完全相同。

1.6.1 时钟系统
1.6.1.1 SoC时钟系统简介
	1、 什么是时钟？SoC为什么需要时钟？
		(1) 时钟是同步工作系统的同步节拍。
		(2) SoC内部有很多器件，譬如CPU、串口、DRAM控制器、GPIO等内部外设，这些东西要彼此协同工作，需要一个同步的时钟系统来指挥。这个就是SoC的时钟系统。

	2、 时钟一般如何获取
		(1) SoC的时钟获得一般有：
			* 外部直接输入时钟信号，SoC有个引脚来输入外部时钟信号。
			* 外部晶振 + 内部的时钟发生器产生时钟。大部分的低频单片机都是这么工作的。
			* 外部晶振 + 内部时钟发生器 + 内部PLL产生高频时钟 + 内部分频器得到各种频率的时钟，210属于这种。

		(2) S5PV210属于第三种。为什么这么设计？
			第一问：为什么不用外部高频晶振产生高频信号直接给CPU？
				主要是因为芯片外部电路不适宜使用高频率，因为传到辐射比较难控制；高频率的晶振太贵了。
			第二问：为什么要内部先高频在分频？
				主要因为SoC内部有很多部件都需要时钟，而且各自需要的时钟频率不同，没法统一供应。因此设计思路是PLL后先得到一个最高的频率（1GHz、1.2GHz），然后各外设都有自己的分频器来分频得到自己想要的频率。

	3、 时钟和系统性能的关系、超频、稳定性
		(1) 一般SoC时钟频率都是可以认为编程控制的，频率高低对系统性能有很大影响。
		(2) S5PV210建议工作频率 800MHz ~ 1.2GHz，一般我们都设置到 1 GHz主频。如果你设置到 1.2GHz 就叫超频。超频的时候系统性能会提升，但是发热也会增大，因此会影响系统的稳定性。

	4、 时钟和外设编程的关联
		(1) 每个外设工作都需要一定频率的时钟，这些时钟都是由时钟系统提供的。时钟系统可以编程控制工作模式，因此我们程序员可以为每个外设指定时钟来源、时钟分频系统、从而制定这个外设的工作时钟。

	5、 时钟和功耗控制的关系
		(1) SoC中各种设备工作时，时钟频率越高其功耗越大，发热越大，越容易不稳定，需要外部散热条件越苛刻。
		(2) SoC内部有很多外设，这些外设不用的时候最好关掉（不关掉会一定程度浪费电），开关外设不是通过开关，而是通过时钟。也就是给某个外设断掉时钟，这个外设就不工作了。

1.6.2 S5PV210的时钟系统简介
1.6.2.1 时钟域：MSYS、DSYS、PSYS
	1）因为S5PV210的时钟体系比较复杂，内部外设模块太多，因此吧整个内部的时钟划分为3大块，叫做3个域。

	2）MSYS：CPU（Cortex-A8内核）、DRAM控制器（DMC0、DMC1）、IRAM&IROM ...
	3）DSYS：都是和视频显示、编解码等有关的模块
	4）PSYS：和内部的各种外设时钟相关，譬如：串口、SD卡接口、I2C、AC97、USB等。

	5）为什么内部要分为三个域，怎么划分的？ 
		因为210内部的这些模块批次工作时钟速率差异太大了，所以有必要吧高速的放在一起，相对低速的放一起。

1.6.3.2 时钟来源：晶振 + 时钟发生器
	1）210外部有4个晶振接口，设计班子硬件时可以根据需要来决定在哪里结晶振。接了晶振之后上电相应的模块能产生振荡，产生原始时钟。原始时钟再经过一些列的筛选开关进入相应的PLL电路生成倍频后的高频时钟。高频时钟再经过分频到达芯片内部各模块上。（有些模块，譬如串口内部还有进一步的分频进行再次分频使用）

1.6.2.3 PLL：APLL、MPLL、EPLL、VPLL
	1）APLL：Cortex-A8内核 MSYS域
	2）MPLL & EPLL：DSYS、PSYS
	3）VPLL：Vedio视频相关模块

1.6.3 S5PV210时钟域详解
1.6.3.1 MSYS域 
	ARMCLK：给CPU内核工作的时钟，也就是所谓的主频
	HCLK_MSYS：MSYS域的高频时钟，给DMC0和DMC1使用
	PCLK_MSYS：MSYS域的低频时钟
	HCLK_IMEM：给iROM和iRAM（合称iMEM）使用

1.6.3.2 DSYS域
	HCLK_DSYS：DSYS的高频时钟
	PCLK_DSYS：DSYS的低频时钟

1.6.3.3 PSYS域
	HCLK_PSYS：PSYS的高频时钟
	PCLK_PSYS：PSYS的低频时钟
	SCLK_ONENAND：

总结：210内部的各个外设都是接在（内部AMBA总线）总线上面的，AMBA总线有1条高频分支叫AHB，有1条低频分支叫APB。上面的各个域都有各自对应的HCLK_XXX和PCLK_XXX,其中HCLK_XXX就是 XXX 这个域中AHB的工作频率，PCLK_XXX 就是 XXX 这个域中APB总线的工作频率。
	SoC内部的各个外设其实是挂载总线上工作的，也就是说这个外设的时钟来自于他挂在的总线，譬如串口UART挂在PSYS域下的APB总线上，因此串口的时钟来源是PCLK_PSYS。我们可以通过记住和分析上面的这些时钟域和总线数值，来确定我们各个外设的具体时钟频率。

1.6.3.4 各时钟典型值（默认值，iROM中设置的值）
	1）当210刚上电时，默认是外部晶振 + 内部时钟发生器产生的24MHz频率的时钟直接给ARMCLK的，这是系统主频就是24MHz，运行非常慢。
	2）iROM代码执行时第 6 步中初始化了时钟系统，这时给了系统一个默认推荐运行频率。这个时钟频率是三星推荐的210工作性能和稳定性最佳的频率。
	3）各时钟的典型值。
		• freq(ARMCLK) 			= 1000 MHz 		主频
		• freq(HCLK_MSYS) 		= 200 MHz 		DMC0 DMC1
		• freq(HCLK_IMEM) 		= 100 MHz 		iROM iRAM 
		• freq(PCLK_MSYS) 		= 100 MHz 		...
		• freq(HCLK_DSYS) 		= 166 MHz 		display clk 高速
		• freq(PCLK_DSYS) 		= 83 MHz 		display clk 低速
		• freq(HCLK_PSYS) 		= 133 MHz 		高速 ... 
		• freq(PCLK_PSYS) 		= 66 MHz 		低速内部外设，串口
		• freq(SCLK_ONENAND) 	= 133 MHz, 166 MHz

1.6.4 S5PV210时钟体系框图详解
	1）两张图是一个渐进关系。第一张图从左到右一次完成了原始时钟生成->PLL倍频得到高频时钟->初次分频得到各总线时钟；第二张图是从个中间时钟（第一张图中某个步骤生成的时钟）到各外设自己使用的时钟（实际就是个别外设自己在额外分频的设置）。可见，第一张图是关键，第二张图是进一步分析各外设时钟来源的关键。

	2）要看懂时钟体系框图，2个符号很重要：一个是MUX开关，另一个是DIV分频器。
		MUX开关：是个 或门，实际对应某个寄存器的某几个bit位的设置，设置值决定了那条通道的，分析这个可以知道右边的时钟是从左边那条路过来的，从而知道右边的时钟值。
		DIV分频器：是一个硬件设备，可以对左边的频率进行n分频，分频后的低频时钟输出到右边。分频器在编程时实际对应某个寄存器中的某几个bit位，我们可以通过设置这个寄存器的这些对应bit位来设置分频器的分频系数（譬如：左边进来的时钟是80MHz，分频系统设置为8，则分频器右边输出的时钟频率为10MHz）。

		寄存器中的clock source X就是在设置MUX开关；clock divider control寄存器就是在设置分频器分频系数。


1.6.5 时钟设置的关键寄存器
1.6.5.1 xPLL_LOCK
	1）xPLL_LOCK 寄存器主要控制PLL锁定周期的。 低频 --> 高频的周期

1.6.5.2 xPLL_CON/xPLL_CON0/xPLL_CON1
	1）PLL_CON寄存器主要用来打开/关闭PLL电路，设置PLL的倍频参数，查看PLL锁定状态等。

1.6.5.3 CLK_SRCn(n:0 - 6)
	1）CLK_SRC进村器是用来设置射中来源的。对应时钟框图中的 MUX开关。

1.6.5.4 CLK_SRC_MASKn
	1）CLK_SRC_MASK决定MUX开关n选1后是否能继续通过。默认的时钟都是打开的，好处是不会因为某个模块的时钟关闭而导致莫名其妙的问题，坏处是功耗控制不精细、功耗高。

1.6.5.5 CLK_DIVn
	1）各模块的分频参数配置。

1.6.5.6 CLK_GATE_X
	1）类似于 CLK_SRC_MASK,对时钟进行开关控制。

1.6.5.7 CLK_DIV_STASn
1.6.5.8 CLK_MUX_STATn
	1）这两个状态寄存器，用来查看DIV和MUX的状态是否已经完成还是在进行中。

总结：齐总最重要的寄存器有3类：CON、SRC、DIV。其中CON决定PLL倍频到多少，SRC决定走那一路，DIV决定分频多少。


1.6.6 汇编实现时钟设置代码详解
	1）失踪设置的步骤分析：
		第一步：先选择不适用PLL。让外部24NHz原始时钟直接过去，绕过APLL那条路。
		第二步：设置锁定时间。默认值是 0x0FFF，我们设置为 0xFFFF。
		第三步：设置分频系数。决定由 PLL 出来的最高时钟如何分频得到各个分时钟。
		第四步：设置PLL，主要是设置 PLL 的倍频系数，决定由输入端 24MHz 的原始频率可以得到多大的输出频率。我们按照默认设置值设置输出为 ARMCLK 为 1GHz。
		第五步：设置各种时钟开关。前面4步已经设置好了所有的开关和分频系数，本步骤打开 PLL 后 PLL 开始工作，锁定频率后输出，然后经过分频得到各个频率。

	总结：以上五步，其实真正涉及到的寄存器只有5个。

	2）CLK_SRC寄存器的设置分析
		CLK_SRC寄存器其实是用来设置MUX开关的。在这里先将寄存器设置为全0，主要是bit0和bit4设置为0，表示APLL和MPLL暂时都不启用。

	3）CLK_LOCK寄存器的设置分析
		设置PLL锁定延时的。官方推荐设置 0xFFF，我们设置为0xFFFF。

	4）CLK_DIV寄存器的设置分析
		0x14131440这个之的含义：
			PCLK_PSYS = HCLK_PSYS / 2
			HCLK_PSYS = MOUT_PSYS / 5
			PCLK_DSYS = HCLK_DSYS / 2

			HCLK_MSYS = ARMCLK / 5
			ARMCLK = MOUT_MSYS / 1

1.6.7 汇编实现时钟设置代码详解
	1）PLL倍频的相关计算
		1、 我们设置了APLL和MPLL两个，其他两个没有关系。
		2、 APLL和MPLL设置的关键都是M、P、S三个值，这三个值都来自于官方数据手册推荐值
		3、 M、P、S的设置依赖《4.2 C语言位运算》

	2）结合寄存器、时钟框图、代码三者综合分析S5PV210的时钟系统
		1、 分析时记得在图上做标记（把MUX开关选哪个和DIV分频多少都标出来）然后就非常清楚了。

1.6.8 C语言实现时钟设置代码详解


1.7 串口通信
1.7.1 通信涉及到的几个概念
一、
	1）最早通信：烽火台、狼烟 --> 信件 --> 电子通信（电报、电话、网络信号）。

	2）通信中最重要的两个方面：信息的表示、解析方法 + 信息的传输方法。

	3）通信双方实现需要约定好信息的标识方法和解析方法，做到一致，否则信息不能有效传递。

	4）信号的传输方法是指经过编码后的通信信息如何在传输介质上传输的过程。

	总结：通信过程分为三个步骤：首先发送方先按照信息编码方式对有效信息进行编码（编程可以再通信线路上传输的信号形态），然后编码后的信息在传输戒指上进行传递，输送给接收方；最后接收方接收到编码信息进行解码，解码后得到可以理解的有效信息。

二、
	1）电子通信的概念1：同步通信和异步通信
		1、 同步和异步的区别：首先很多地方都有同步和异步的概念，简单俩说就是发送方和接收方按照同一个时钟节拍工作就叫同步，发送方和接收方没有统一的时钟节拍、而各自按照自己的节拍工作就叫异步。

		2、 同步通信中通信双方按照统一的节拍工作，所以配合很好；一般需要发送方给接收方发送信息的时候发送时钟信号，接收方根据发送方给他的时钟信号来安排自己的节奏。同步通信用在通信双方信息交换频率固定，或者经常通信时。

		3、 异步通信又叫异步通知。在通信双方通信频率不固定时（有时候3ms收发一次，有时3天才收发一次）不适合使用同步通信，而适合异步通信。异步通信时接收方不必一直在意发送方，发送方需要发送信息时会首先给接收方一个信息开始信号，接收方接收到起始信号后就认为后面紧跟着的就是有效信息，才会开始注意接收信息，知道收到发送方发过来的结束标志。

	2）电子通信的概念2：电平信号和差分信号
		1、 电平信号和差分信号是用来描述通信线路传输方式的。也就是说如何在通信线路上表达1和表达0。
		2、 电平信号的传输线中有一个参考电平线（一般是GND），然后信号线上的信号值是由信号线电平和参考电平线的电压差决定。
		3、 差分信号的传输线中没有参考电平，所有都是信号线。然后1和0的表达靠信号线之间的电压差。

		总结：电平信号的2根通信线之间的电平差异容易受到干扰，传输容易失败；差分信号不容易受到干扰因此传输质量比较稳定，现代通信一般都是用差分信号，电平信号几乎没有了。

		总结：看起来似乎相同根数的通信线，电平信号要比差分信号要快；但是实际还是差分信号块，因为差分信号刚干扰强，因此1个发送周期更短。

	3）电子通信概念3：并行接口和串行接口
		1、 串行还是并行主要是考虑通信线的根数，就是发送方和接收方同时可以传递信息量的多少。
		2、 譬如在电平信号下，1根参考电平线 + 1根信号线可以传递1位二进制；如果有3根线（1参考线 + 2根信号线）就可以同时发送2位二进制。
		3、 在差分信号下，2根线（批次差分）可以同时发送1位二进制；如果要同时发送8位二进制，需要16根线。

		总结：听起来似乎并行接口比串行接口要快（串行接口一次只能发送1位二进制，而并行接口一次可以发送多为二进制）要更优秀；但实际上串行接口才是王道，用的比较广泛。因为更信号线，而且对传输线的要求更低、成本更低；而且串行时可以通过提高通信速度来提高总体通信性能。不一定非要并行。

总结：其实经过这么多年的发展，最终胜出的是：异步、串行、差分，譬如USB和网络。
	  串口：异步、串行、电平

1.7.2 串口通信的基本概念
	1） 串口通信的特点：异步、电平信号、串行
		1、 异步：串行通信的发送方和接收方没有时钟同步信号。
		2、 电平信号：串口通信穿线的时间较早，速率较低，传输的距离较近，所以干扰还不太明显，因此当时使用了电平信号传输。后期出现的传输协议都改成了差分信号了。
		3、 串行通信：串口通信每次同时只能传输1个二进制位。

	2）RS232电平和TTL电平
		1、 电平信号是用信号线电平减去参考线电平得到电压差，这个电压差决定了传输值是1还是0。
		2、 在电平信号时多少V代表1，多少V代表0不是固定的，取决于电平标准。譬如RS232电平中： -3V ~ -15V 表示1； +3 ~ +15V 表示0；TTL电平则是 +5V 表示1,0V 表示0；
		3、 不管哪种电平都是为了在传输线上表示1和0，区别在于使用的环境和条件不同。RS232的电平定义比较大，适合干扰大、距离远的情景；TTL电平电压范围小，适合距离近且干扰小的情况。
		4、 我们台式机后面的串口插座就是RS232接口的，在工业上用串口都用这个，传输距离小于15米；TTL电平一般用在开发板内部两个芯片之间。
		5、 对编程来说，RS232电平传输还是TTL电平是没有差异的。所以电平标准对硬件工程师更有意义，而软件工程师只要略懂即可。（把TTL电平和RS232电平混接是不可以的）

	3）波特率
		1、 波特率（bandrate），指的是串口通信的速率，也就是串口通信时每秒中可以传输多少个二进制位。譬如每秒可以传输 115200 个二进制位（传输一个二进制位需要的时间是 1/115200 秒，也就是 8.6 us），波特率及时115200。
		2、 串口通信的波特率不能随意设定，而应该在一些值中去选择。一般最常见的波特率是 9600 或 115200（低端单片机如51常用9600，高端单片机和嵌入式 SoC一般用115200），
		为什么波特率不可以随便指定？
		主要原因：第一，通信双方必须实现设定相同的波特率这样才能成功通信，如果发送方和接收方按照不同的波特率通信则根本收不到，因此波特率最好是大家熟知的而不是随意指定的。
		第二，常用的波特率经过长久的发展，就形成了共识，大家常用的就是9600或者115200。
	
	4）起始位、数据位、就奇偶校验位、停止位
		1、 串口通信时，收发是一个周期一个周期进行的，每周期传输n个二进制位。这一个周期就叫做一个通信单元，一个通信单元是由 起始位 + 数据位 + 奇偶校验位 + 停止位。
		2、 起始位表示发送方要开始发送一个通信单元；数据位是一个通信单元中发送的有效信息；奇偶校验位：用来校验数据位，防止数据位出错。停止位是发送方用来表示本通信单元结束标志的。
		3、 起始位的定义是串口通信标准的事先指定的，是由通信线上电平变化来反映的。
		4、数据位是本次通信真正要发送的数据，串口通信一次发送多少位有效数据是可以设定的（一般可选的有1、7、8、9，99%情况下我们都是选择8位数据位。因为我们一般通过串口发送的文字信息都是ASCII码编码的，而ASCII码中一个字符刚好编码为8位。）
		5、 就加盐位是用来给数据位进行奇偶校验（吧待校验的有效数据逐个加起来，综合为奇数奇偶校验位就为1，总和为偶数奇偶校验位就为0）的，可以再一定程度上防止位反转。
		6、 停止位的定义是串口通信标准的事先指定的，是由通信线上电平变化来反映的。一般来说有1位停止位，1.5位停止位，2位停止位。99%情况下都用1位停止位。

		总结：串口通信时因为是异步通信，所以通信双方事先必须约定好通信参数，这些通信参数包括；波特率、数据位、奇偶校验位、停止位（串口通信中起始位定义是唯一的，所以一般不用选择）

1.7.3 串口通信的基本原理
	1）单工通信和双工通信
		1、 单工通信：单方向
		2、 双工通信：同时双向
		3、 半双工通信：同一时刻只能单一防线。
	2）三根通信线：Rx、Tx、GND
		1、 任何通信都有信息传输载体，或者是由线的或者是无线的。
		2、 串口通信是有线通信，是通过串口线来通信的。
		3、 串口通信线最少需要2根（GND和信号线），可以实现单工通信（Rx + GND）。也可以三根线实现全双工（Rx + Tx + GND）
		4、 一般开发板都会引出SoC上串口引出直接输出的TTL电平的串口（210开发板没有），插座用插针式插座，每个串口引出的都有三根线（Rx + Tx + GND），可以用这些插座直接连接外部的TTL电平的串口设备。

	3）收发双方事先规定好通信参数（波特率baudrate、数据位、奇偶校验位、停止位）等
		1、 串口通信属于基础基本型的通信规约，它自己本身不会去协商通信参数，需要通信前通信双方事先约定好通信参数（一般4个最重要）
		2、 串口通信的任何一个关键参数设置错误，都会导致通信失败。譬如波特率调错了，发送发给发送没问题，但是接收方会乱码。

	4）信息以二进制流的方式在信道上传输。
		1、 串口通信的发送方每隔一定时间（时间固定为 1/boudrate，单位是s）将有效信息（1或者0）放到通信线上去，逐个二进制位的进行发送。
		2、 接收方通过定时（起始时间由读到其实标志开始，间隔时间由波特率决定）读取通信线上的电平高低来区分发送的是1还是0。一次读取数据位、奇偶校验位、停止位，停止位就表示这一个通信单元（帧）结束，然后总监是不定长短的非通信时间（发送方可能紧接着就发送第2帧，也可能半天都不能发送第二帧，这就是异步通信），下来就是第二帧...

		总结：波特率非常中要，波特率易错通信就乱套了。第二，数据位、奇偶校验位、停止位也很重要，否则可能认不清数据。第三，通过串口不管发数字、文本还是命令，都要先对发送内容进行编码，编码成二进制再进行逐个位的发送。

		3、串口发的一般都是字符，一般都是ASCII码编码后的字符，所以一般设置数据位都是8，方便刚好一帧发送1个字符。

	5）DB9接口介绍
		1、 DB9接口是串口通信早期比较常用的一种规范化接口。
		2、 串口通信在早期是计算机与外界通信的主要手段，那时候的计算机都有标准配置的串口以实现和外部通信。那时候就定义了一套标准的串口规约。
		3、 DB9接口中有9根通信线，其中3根很重要，为GND、Tx、Rx，必不可少；剩余6根都是和流控有关的，实现我们是用串口都是来做调试一般都禁用流控，搜易这6根都没用。
		4、 现在一般使用串口时要记得把流控禁止掉，不然可能发生意想不到的问题。

1.7.4 S5PV210 串行通信接口详解1
	1）串口名称
		1、 数据手册中串口控制器在 section8.1 
		2、 串口的官方名称：universal asynchronous reciver and transmitter，通用异步收发器，英文缩写：uart，即串口

	2）S5PV210的串口控制器工作原理框图
		1、 整个串口控制器包含transmitter和reciver两部分，两部分功能彼此独立，transmitter负责210向外部发送信息，reciver负责从外部接收信息到210内部。
		2、 总线角度来讲，串口控制器是接在APB总线上的。对我们编程有印象的是：将来计算串口控制器的源时钟时是以APB总线来计算的。
		3、 transmitter由发送缓冲区和发送移位器构成。我们要发送信息时，首先要将信息进行编码（一般用ASCII码）成二进制流，然后将一帧数据（一般是8位）写入发送缓冲区（从这里以后程序就不用管了，剩下的发送部分是硬件自动的），发送移位器会自动从发送缓冲区读取一帧数据，然后自动移位（移位的目的是将一帧数据的各个位分别拿出来）将其发送到Tx通信线
		4、 reciver由接收缓冲区和接收移位器构成。当有人通过串口线向我发送信息时，信息通过Rx通信线进入我的接收移位器，然后接收移位器自动移位将该二进制位保存入我的接收缓冲区，接收完一帧数据后reciver会产生一个中断给CPU，CPU收到中断后即可知道reciver接收满了一帧数据，就会来读去这帧数据。

		总结：发送缓冲区和接收缓冲区水管件。发送移位器和接收移位器的工作都是自动的，不用编程控制的，所以我们写串口的代码就是：首先初始化（实质就是读写寄存器）好串口（包括发送控制器和接收控制器），然后发送信息时直接写入发送缓冲区，要接收信息时直接去接收缓冲区读取即可。可见串口底层的工作（譬如怎么移位的、起始位怎么定义的、TTL电平还是RS232电平等）时程序员是隐藏的，程序员不用去管它。软件工程师对串口操作的接口就是发送/接收缓冲区（实质就是寄存器，操作方式就是读写内存）

		5、 串口控制器中有一个波特率发生器，作用是产生串口发送/接收节拍时钟。波特率发生器其实就是个时钟分频器，他的工作需要源时钟（APB总线来），然后内部将源失踪进行分频（软件设置寄存器来配置）得到目标时钟，然后再用这个目标失踪产生波特率（硬件自动的）。

	3）自动流控（AFC: Auto flow control）
		1、 为什么需要流控？ 流控的目的是让串口通信非常可靠，在发送方速率比接收方块的时候流控可以保证发送和就收不会漏掉东西。
		2、 现在为什么不使用流控？现在计算机之间有更好更高级（usb、internet）的通信方式，串口已经基本被废弃了。现在串口的用途更多是SoC用来调试信息的。由于调试信息不是关键信息、而且由于硬件发展串口速度已经慢的要死了，所以硬件都能协调发送和接收速率，因此流控已经失去意义了，所以现在基本都废弃了。

1.7.5 S5PV210 串行通信接口详解2
	本来串口的功能就是以上部分，但是后来发展的技术发展给串口叠加了一些高级功能。

	1）FIFO模式及其作用
		1、 典型的串口设计发送/接收的缓冲区只有个1个字节，每次放/接收只能处理1帧数据。这样在单片机中没什么问题，但是到复杂SoC中（一般有操作系统的）就会有问题，会导致效率低下，因为CPU需要不断切换上下文。
		2、 解决方案就是想办法扩展串口控制器的发送/接收缓冲区，譬如将发送/发送缓冲区设置为64字节，CPU一次过来直接给发送缓冲区64字节的待发送数据，然后transmitter慢慢发，发完再找CPU要64字节数据。但是串口控制器原来的发送/接收缓冲区是固定的1字节长度的，所以做了个变相的扩展，就是FIFO。
		3、 FIFO就是first in first out，先进先出。fifo其实是一种数据结构，这里这个大的缓冲区叫FIFO是因为这个缓冲区的工作方式类似于FIFO这种数据结构。

	2）DMA模式及其作用
		1、 DMA就是direct memory acess，直接内存访问。DMA本来技术的核心就是在交换数据时不需要CPU参与，模块可以自己完成。
		2、 DMA模式要解决的问题和上面FIFO模式是同一个问题，就是串口发送/接收要频繁的折腾CPU造成CPU反复切换上下文导致系统效率低下。
		3、 传统的串口工作方式（无FIFO无DMA）效率是最低的，适合低端单片机；高端单片机上CPU事无繁忙所以都需要串口能够自己完成大量数据发送/接收。这时候就需要FIFO或者DMA模式。FIFO模式时一种轻量级的解决方案，DMA模式适合大量数据并发式的发送/接收时。

	3）IrDA模式及其用法
		1、 IrDA其实就是红外，红外就是红外线通信（电视机、空调遥控器就是红外线通信）。
		2、 红外通信的原理是发送方固定时间间隔时间向接收方方红外信号（表示1或者0）或者不发送红外信号（表示0或者1），接收方每隔固定时间判断有无红外信号来接收1和0。
		3、 分析可知，红外通信和串口通信非常像，都是每隔固定时间发送1或者0（判断1或者0的物理方式不同）给接收方来通信。因此210就利用串口通信来实现了红外发送和接收。
		4、 210的某个串口支持IrDA模式，开启红外模式后，我们只需要乡川口写数据，这些数据就会以红外光的方式向外发射出去（需要一些外部硬件支持），然后接收方式这些红外数据即可解码得到我们的发送信息。

1.7.6 S5PV210 串行通信接口详解3
	1）串口通信与中断的关系
		1、 串口通信分为发送/接收两部分。发送方一般都不需要中断即可完成发送，接收方必须（一般来说必须，也可以轮训方式接收）中断来接收。
		2、 发东方可以选择使用中断，可以选择不适用中断。
		使用中断的工作情景是：发送方先设置号中断并绑定一个中断处理程序，然后发送方丢一帧数据给transmitter，transmitter发送耗费一段时间来发送这一帧数据，这段时间内发送方CPU可以去做别的事情，等transmitter发送完成后会产生一个TXD中断，该终端会导致事先绑定的中断处理程序执行，在中断处理程序中CPU会且换回来继续给transmitter放一帧数据，然后CPU切换离开；

		不使用中断的工作情景是：发送方事先禁止TXD中断（当然也不需要给相应的中断处理程序了），发送方CPU给一帧数据到transmitter，然后transmitter耗费一段时间来发送数据，这U盾那花四溅CPU在这等着（CPU没有切换去做别的事情）。CPU是怎么知道transmitter发送完了？原来是有个状态寄存器，状态寄存器中有一个位叫做发送缓冲区空标志位，transmitter发送完成（发送缓冲区空了）就会给这个标志位置位，CPU就是通过不断查询这个标志位为1还是0来指导发送是否已经完成的。

		3、 因为串口通信时异步的，异步的意思就是发送方占主导权的。也就是说发送方随时想发就能发，但是接收方只会时刻等待才不会丢失数据。所以这个差异就导致发送方可以不用中断，而接收方不得不使用中断模式。

	2）210串行通信接口的时钟设计
		1、 串口通信为什么需要时钟？ 因为串口通信需要一个固定的波特率，所以transmitter和reciver都需要一个时钟。
		2、 时钟信号从哪里来？源时钟信号时外部APB总线（PCLK_PSYS 66MHz）提供给串口模块的（这就是为什么我们说串口时挂在APB总线上的），然后进到串口控制器内部后给波特率发送器（实质是一个分频器）,在波特率发生器中进行分频，分频后得到一个低频时钟，这个时钟就是给transmitter和receiver使用的。
		3、 串口通信中时钟的设置主要看寄存器的设置。中断的有：寄存器源设置（为串口控制器选择源时钟，一般选择为PCLK_PSYS，也可以是SCLK_UART），还要波特率发生器的寄存器。
		4、 波特率发生器有2个重要的寄存器：UBRDIVn和UDIVSLOTn，其中UBRDIVn是主要的设置波特率的寄存器，UDIVSLOTn是用来辅助设置的，目的是为了校准波特率的。


1.7.7 S5PV210 串行通信编程实战1
	1）整个程序流程分析
		1、 包含两部分：uart_init 、 uart_putchar

	2）串口控制器初始化关键步骤
		1、 初始化串口TX RX引脚所对应的GPIO。（差原理图可知TX和RX分别对应GPA0_0和GPA0_1）
		2、 GPA0_CON : 0xE0200000, bit[0:3] = 0b0010 bit[7:4] = 0b0010
		3、 关键寄存器 UCON0 ULCON0 UMCON0 UFCON0 UBRDIV0 UDIVSLOT0

	3）主要几个寄存器
		1、 ULCON0 = 0x3 	// 8数据位 0校验位 1停止位
		2、 UCON0 = 0x5 		// 发送和接收都是轮训模式
		3、 UMCON0 = 0x0 	// 禁止modem，afc
		4、 UFCON0 = 0x0 	// 禁止FIFO模式
		5、 UBRDIV0 = 		// 和波特率有关
		6、 UDIVSLOT0 =  	// 和波特率有关

	4）在C源文件中定义访问寄存器的宏

1.7.8 S5PV210 串行通信编程实战2
	1）串口Tx Rx对应的GPIO的初始化

	2） UCON、ULCON、UMCON、UFCON等主要控制寄存区

	3）波特率的计算和设置
		1、 第一步：用PCLK_PSYS和波特率计算的到 UBRDIV0 + 余数
		2、 第二步：用 余数 * 16 得到 UDIVSLOT0
	4）串口发送和接收函数的编写

	5）综合调试

	6）扩展练习-更改波特率后再调试

1.7.9 uart stdio的移植1
	1）什么是stdio
		1、 #include <stdio.h>
		2、 stdio：standard input output，标准输入输出
		3、 标准输入输出就是操作系统定义的默认的输入输出和输出通道。一般在PC机情况下标准输入指的是键盘，标准输出就是屏幕。
		4、 printf函数和scanf函数可以和底层输入/输出函数绑定，然后这两个函数就可以和stdio绑定起来。也就是说我们直接调用printf函数输出，内容就会从标准输出输出出去。
		5、 在这里，标准输出当然不是屏幕，而是串口。标准输入也不是键盘，而是串口。

	2）printf函数的工作原理
		1、 pirntf函数工作时内部实际调用了2个关键函数：一个是vsprintf函数（主要功能是格式化打印信息，最终得到纯字符串格式的打印信息等待输出），另一个就是真正的输出函数putc（操控标准输出的硬件，将信息发送出去）。

	3）移植printf函数的三种思想
		1、 我们希望在我们的开发板上使用printf函数进行（串口）输出，使用scanf函数进行（串口）输入，就像在PC机上用键盘和屏幕进行输入输出一样。因此就需要移植printf函数/scanf函数。
		2、 这里只是移植而不是编写，不自己从头编写。
		3、 一般移植printf函数可以有三个途径获取printf的实现源码：最原始最原本的来源就是Linux内核中的printk，难度较大；稍微简单的方法是从uboot中移植printf；更简单的就是直接使用别人移植好的。
		4、 此处课程使用第三种方法，别人移植好的printf函数来自于友善之臂的Tiny210的逻辑教程中提供的。

	4）移植好的printf介绍

1.7.10 uart stdio的移植2
	1）修改Makefile进行printf移植

	2）Makefile及gcc的库文件介绍

	3）多文件夹裸机工程的结构解析

	4）编译运行及测试

1.7.11 uart stdio的移植3
	1）在移植后的uart_printf项目中添加link.lds连接脚本，指定链接地址到0xd0020010。

	2）gcc可变参数及va_arg介绍
		1、 printf函数中首先使用了C语言的可变参数 va_start/va_arg/va_end;
		2、 先看着三个。

	3）vsprintf函数详解
		printf
			-> vsprintf
				-> vsnprintf
					-> number
						-> putc

		vsprintf函数的作用是按照printf穿进去的格式化标本，对变参进行处理，然后将之格式化后缓存起来一个事先分配好的缓冲区。printf后半段调用putc函数将缓冲区中格式化好的字符串直接输出到标准输出。

1.7.12 串口实验烧录问题总结
	1）usb下载的问题
		1、 
	2）SD卡镜像烧录

	3）连接脚本的影响
		1、 bin文件大于16KB怎么办？
			通过USB下载最多也只能下载96KB大小的bin，如果大小大于96KB肯定放不下会出错。如果用SD卡启动，那么mkv210_image.c决定了bin文件最大不能超过16KB。

		2、 超过了怎么办？
			第一，在USB下载时，可以先下载一个x210_usb.bin，然后再将逻辑程序连接到0x23E00000，然后在修改dnw中下载地址，讲裸机代码下载到0x23E00000运行。（这时候不需要重定位了）
			第二，在SD卡启动时，将整个裸机工程分为2本分；第一部分大小16KB以内，第二部分方剩下的（放在SD卡的后面的某个扇区开始的位置，譬如放在第50个扇区开始的位置），然后在裸机代码中进行重定位（SD卡中重定位）。

1.8.1 按键和CPU的中断系统
	2）按键是物理特性
		1、 平时没按时，弹簧将弹片弹开（电路断开），按下是弹片连接（电路导通）。
		2、 一般按键都有4个引脚，分2对：其中一对是常开触点（向上面描述的平时断开的，按下则连接）另一种是常闭触点（按下则分开，不按则连接）。

	2）按键的电学原理（结合原理图分析）
		1、 硬件接法：	SW5:GPH0_2 		SW6:GPH0_3		SW78910:GPH0_0123
		2、 按键电路连接分析：平时按键没按下，按钮内部断开，GPIO引脚处电压为高电平；当有人按下按钮时，按钮内部导通，外部VDD经过电阻连接到地，形成回路，此时GPIO引脚处电压就变成低电平。此时VDD电压全部分压在了电阻上（这个电阻就叫分压电阻，这个电阻不能太小，因此电阻的功率是U*U/R）。

	3）按键属于输入类设备
		1、 按键一般用来做输入设备，由人向SoC发送按键信号。
		2、 有些设备就是单纯的输入设备，譬如按键、触摸屏；有些设备是输出设备，譬如屏幕、喇叭等。

	4）按键的2中相应方法
		1、 SoC处理按键有两种思路：轮询方式和中断方式。
		2、 轮询方式，就是SoC主动的每隔一段时间去读取（按键所对应的）GPIO的电平高低，以此获得案件信息；缺点碍于CPU一直注意按键时间，会印象CPU做其他事情。
		3、 中断方式，就是SoC事先设定好GPIO触发所对应的中断处理程序ISR，当外部按键按下或弹开时会自动触发GPIO对应的外部中断，导致ISR执行，从而自动处理按键信息。

1.8.2 轮训方式处理按键
	1）X210开发板的按键接法
		1、 查看原理图：SW5:GPH0_2 		SW6:GPH0_3		SW78910:GPH0_0123
		2、 原理图上可以看出：按下时是低电平，弹起时是高电平。

	2）按键对应的GPIO模式设置
		1、 按键街道GPIO上，按键按下还是弹起，决定外部电路的接通与否，从而决定这个GPIO引脚的电压是高还是低；这个电压可以作为这个GPIO引脚的输入信号，此时GPIO配置为输入模式，即可从SoC内部读取该引脚的电平为1还是0（及高还是低）。
		3、 GPH0CON：0xE0200C00	GPH0DAT：0xE0200C04		GPH1CON：0xE0200C40	GPH1DAT：0xE0200C44
		4、 将CON寄存器中将GPIO设置为input模式，然后去读取DAT寄存器（弹起高电平：1，按下低电平：0）。
		
	3）轮训方式处理按键的程序流程
		1、 初始化GPIO
		2、 循环读取电平值

	4）代码编写调试

1.8.2 轮训方式处理按键

1.8.3 串口输出和按键消抖
	

1.8.4 S5PV210的中断体系介绍
	1）什么是中断
		1、 中断的发明是用来解决宏观上的并行需要的。宏观就是从整体上来看，并行就是多件事情都完成了。
		2、 微观上的并行，就是指的真正的并行，就是精确到每一秒甚至每一刻，多个事情都在同时进行的。宏观上面的并行并不等于微观的并行，有时候宏观上是并行的，微观上是串行的。
		3、 单核CPU中是没有真正的并行的，微观上是串行的。
		4、	|
				|
			|
			这就是一个中断。
		5、 为什么需要中断？因为单核CPU实际上无法并行，但是通过中断机制，可以实现假并行（宏观上的并行，微观上的实际还是串行）。

	2）SoC对中断的实现机制：异常向量表
		1、 异常向量表示CPU中某些特定地址的特定定义。当中断发生的时候，中断要想办法通知CPU去处理中断，怎么做到？这就要靠异常向量表。
		2、 在CPU设计时，就实先定义了CPU中一些特定地址作为特定异常的入口地址（譬如定义 0x00000000 地址为复位异常向量地址，则发生复位异常时CPU会自动跳转到 0x00000000 地址去执行指令。又譬如外部中断对应的异常向量地址为 0x00000008，那么则发生外部中断后，CPU会硬件自动跳转到 0x00000008 地址去执行指令。）
		3、 以上是CPU硬件设计时对异常向量表的支持，下来就是需要软件支持了。硬件已经决定了发生什么异常CPU自动跳转PC到那个地址去执行，乳尖需要做的就是把处理这个异常的代码的首地址填入这个异常向量地址。

	3）S5PV210的异常向量表
		1、 异常向量表在1.2.14节讲过，可以回去看一下。
		2、 异常向量表中各个向量表的相对应位置是固定的，但是他们的起始地址是不固定的，各种SoC可以不一样，而且复杂ARM中还可以让用户来软件设置这个异常向量表的基地址。
		3、 扩展到所有架构的CPU中：所有架构（譬如51垫片机、PIC单片机）的CPU实现中断都是通过异常向量表实现的，这个机制是不变的；但是不同CPU异常向量表的架构和位置是不同的。

	4）异常和中断的区别和联系
		1、 针对SoC来说，发生复位、软中断、中断、快速中断、取指令异常、数据异常等，我们都统一叫异常。所以说中断其实是异常的一种。
		2、 异常的定义就是突发事件，打断了CPU的正常常规业务，CPU不得不跳转到异常向量表中去执行异常处理程序。中断是异常的一种，一般特质SoC内部外设产生的打断SoC常规业务，或者外部中断（SoC的GPIO引脚传会来的中断）。


1.8.5 异常向量表的编程处理
	1）像内存一样去访问异常向量表
		1、 210的异常向量表可以改变（在CP15协处理器中），以适应操作系统的需求。但是目前来说系统刚启动时，此时DRAM尚未初始化，程序都在SRAM中运行。210在iRAM中设置了异常向量表，提供暂时性使用。
		2、 查210的 iROM_application_note 文档中iRAM的地址分配，可知，iRAM中的异常向量表其实地址为 知道异常向量表的起始地址后各个向量的入口就好办了。
		3、 

	2）函数名的实质就是函数的首地址
		1、 函数名在C语言中的理解方法和变量名其实没区别。编译器会把这个函数的函数体对应的代码段和这个函数名（实质是符号）对应起来，等我们在使用这个函数名符号时，编译器会将函数的函数体实际上做替换。因为函数体都不止4字节，而函数名这个付哈偶只能对应1个地址，所以实际对应的势函数体那一个代码段的首地址。
		2、 那C语言中的语法来讲，函数名就是这个函数的函数指针。

		总结：当我们将异常处理程序的首地址和异常向量表绑定起来后，异常处理初步阶段就完成了。到目前可以保证相应异常发生后，硬件自动跳转到对应异常向量表入口区执行时，可以执行到我们实先绑定的函数。

	3）为什么中断处理要先在汇编中进行
		1、 中断处理要注意保护现场（中断从SVC模式来，则保存SVC模式下的必要寄存器的值）和恢复现场（中断处理完成后，准备返回SVC模式前，要将保存的SVC模式下的必要寄存器的值恢复回去，不然到了SVC模式后寄存器的值乱了，SVC模式下原来正在进行的常规任务就被你搞坏了）。
		2、 保存现场包括：第一，设置IRQ栈；第二，保存LR；第三，保存R0~R12。
		3、 为什么要保存LR寄存器？要考虑中断返回的问题。中断ISR执行后如何返回SVC模式下去接着执行原来的代码。中断返回起始取决于我们进入中断时如何保存现场。中断返回时关键的2个寄存器就是PC和CPSR。所以我们在进入IRQ模式时，应该将SVC模式下的下一句指令的地址（中断返回地址）和CPSR保存起来，将来恢复时才可以将终端返回地址给PC，将保存的CPSR给CPSR。
		4、 中断返回地址就保存在LR中，而CPSR（自动）保存在（IRQ模式下的）SPSR中。

	4）汇编保存现场和恢复现场
		1、 保护现场关键是保存：中断处理程序的返回地址，r0-r12（cpsr是自动保存的）
		2、 恢复现场主要是恢复：r0-r12，pc，cpsr

1.8.6 S5PV210的向量中断控制器
	1）异常处理的两个阶段
		1、 可以将异常处理分为2个阶段来理解。第一个阶段是异常向量表跳转；第二个阶段就是进入了真正的异常处理程序irq_handler之后的部分。

	2）后顾处理的第一阶段（异常向量表阶段）处理
		1、 第一个阶段之所以能够进行，主要是依赖CPU设计时提供的异常向量表机制，第一个阶段的主要任务是从异常发生到相应异常并且保存/恢复现场、跳转到真正的异常处理程序处。
		2、 第二个阶段的目的是识别多个中断源中究竟是哪一个发生了中断，然后调用相应的中断处理程序来处理这个中断。

	3）S3C2440的第二阶段处理过程
		1、 第一个问题：怎么找到具体是哪个中断？
			S3C2440的中断控制器中有一个寄存器（32位的），寄存器的每一个未对应一个中断源（为了解决支持更多中断源，2440有设计了一个子中断机制。在一级中断寄存器中有一些中断是共用的一个bit位，譬如AC97和WDT。对于共用中断，用子中断来区分究竟是哪一个发生了中断）。
		2、 第二个问题，怎么找到对应的isr的问题？
			首先给每个中断做个编号，进入isr_handler之后先通过查阅中断源寄存器和子中断寄存器（中哪一位为1）确定中断的编号，然后用这个编号去isr数组（中断初始化时事先设定好的，就是把各个中断的isr的函数名组成一个数组，用中断对应的编号作为索引来查询这个数组）中查阅得到isr地址。

		评价：2440的中断处理设计不是特别优秀：第一个过程中使用子中断搞成2级的很麻烦；第二个过程中计算中断编号是个麻烦事，很费时间。而中断处理的时间是很宝贵的（系统有一个性能指标，实时性。实时性就是中断发生到相应的时间，这个时间越短越好。）
	4）S5PV210的第二阶段处理过程
		1、 第一个问题：怎么找到具体是哪个中断？
			S5PV210中因为支持的中断源很多，所以直接设计了4个中断寄存器，每个32位，每位对应一个中断源。（理论上210最多支持128个中断，实际支持不足128，有些位是空的）；210没有子中断寄存器，每个中断源都是并列的。当中断发生时，在irq_handler中依次去查询4个中断源寄存器，看哪一个的哪一位被置1，则这个位对应的寄存器就发生了中断，即找到了中断编号。

		2、 第二个问题，怎么找到对应的isr的问题？
			210中支持的中断源多了很多，如果还是用2440的那一套来寻找isr地址就太慢了，太影响实时性了。于是210开拓了一种全新的寻找isr的机制。210提供了很多的寄存器来解决每个中断源对应isr的寻找问题，具体过程见下节。实现的效果是：当发生相应的中断时，硬件会自动的将相应的isr推入一定的寄存器中，我们软件只要去这个寄存器中执行就行了。

	5）总结：第一阶段都相同，第二阶段各不同
		1、 第一阶段（异常向量表阶段）2440和210几乎是完全相同。实际上几乎所有的CPU在第一阶段都是相同的。
		2、 第二阶段就彼此不同。各个SoC根据自己对实时性的要求，和支持的中断的多少，各自发明了各自处理中断，找到中断编号，进一步找到对应isr地址的方式。

1.8.7 S5PV210中断处理的主要寄存器
	1）VICnINTENABLE和VICnINTENCLEAR
		1、 VICnINTENABLE 对应 interrupt enable 负责相应中断的使能。
		2、 VICnINTENCLEAR 对应 interrupt enable clear 负责相应中断的禁止。
		3、 当我们向使能（意思就是启用这个终端，意思就是当硬件产生中断时CPU能接收到）某个中断时，主要在这个中断编号对应的VICnINTENABLE的相应bit位写1即可（注意这个位写1其他为写0对其他位无影响）；如果想禁止某个中断源，只要想VICnINTENCLEAR中相应的位写1即可。

		注意：这里的设计一共有两种：有些CPU事中断使能和禁止是一个寄存器位，写1使能写0至今（或者反过来...），这样的中断使能设计就要非常小心，要使用读改写三部曲来操作；另一种就是使能和禁止分开为2个寄存器，要是能就写使能寄存器，要禁止就写禁止寄存器。这样的好处是我们使能/禁止操作时不需要读改写，直接写即可。

	2）VICINTSELECT
		1、 设置各个中断的模式为irq还是fiq。一般都设置成irq
		2、 IRQ和FIQ究竟有何区别。210中支持2中中断，irq和fiq。irq是普通中断，fiq是快速中断。快速中断提供一种更快速响应处理的中断通道，用于实时性要求很高的中断源。fiq在CPU 设计时预先提供了一些机制保证fiq可以被快速处理，从而保证实时性。fiq的限制就是只能有一个中断源被设置fiq，其他都是irq。
		3、 CPU如何保证fiq比irq块？
			有两个原因：一、fiq有专用的r8-r12，因此在fiq的isr中可以直接使用r8-r12而不用保存，这就能节省时间：二、异常向量表中fiq是最后一个异常向量入口。因此fiq的isr不需要跳转，可以直接卸载原地，这样就比其他异常少跳转一次，省了些时间。

	3）VICIRQSTATUS和VICFIQSTATUS
		1、 中断状态寄存器，是只读的。当发生了中断时，硬件会自动将该寄存器的对应位置为1，表示中断发生了。软件在处理中断第二阶段的第一阶段，就是考查询这个寄存器来得到中断编号的。

	4）VICnVECTPRIORITY[0-31]
		1、 中断的优先级，设置多个中断同时发生时先处理谁后处理谁的问题。一般来说高优先级的中断可以打断低优先级的中断，从而嵌套处理中断。当然了有些硬件/软件可以设置不支持中断嵌套。

	5）VICnVECTADDR[0-31]、VICnADDR
		1、 这三个寄存器和210中断处理第二阶段的第二阶段有关。
		2、 VICnVECTADDR[0-31]这32个寄存器分别用来存放真正的各个中断对应的isr的函数地址。相当于每一个中断源都有一个VECTADDR寄存器，程序员在初始化中断的时候，把这个中断的isr地址直接放入这个中断对应的VECTADDR寄存器即可。

		3、 VICnADDR这个寄存器是只需要读的，它里面的内容是有硬件自动设置的。当发生了相应的中断时，硬件会自动识别中断编号，并且会自动找到这个中断的VECTADDR寄存器，然后将其读出赋值到VICnADDR中，供我们使用。这样的设计避免了软件查找中断源和isr，节省了时间，提高了210的中断响应速度。


1.8.8 S5PV210中断处理的编程实践
	1）上节中代码中的小问题
		编译时发现再解决。

	2）中断控制器初始化
		1、 主要工作有：第一阶段的绑定异常向量表到异常处理程序；禁止所有中断；选择所有总段类型为IRQ；清理VICnADDR寄存器为0。
	3）中断的使能与禁止
		1、 先根据中断号判断这个中断属于VIC几，然后再用中断源减去这个中断VIC对应的基号得到第几位。
	4）绑定自己实现的isr到VICnVECTADDR
		1、 搞清楚2个寄存器的区别：VICnVECTADDR和VICnADDR
		2、 VICRCTADDR寄存器一共 4 * 32 个，每个中断源都有一个VECTADDR 寄存器，我们应该将自己为这个中断源写的isr地址丢到这个中断源对应的VECTADDR寄存器中去即可。
	5）真正的中断处理程序如何获取isr
		1、 当发生中断时，硬件会自动吧相应的中断源的isr地址从VICnVECTADDR寄存器中推入VICnADDR寄存器中，所以我们第二阶段的第二阶段isr_handler中，中需要到相应的VICnADDR中去拿isr地址，调试即可。

总结：中断函数流程：
		初始化时  ： 入口处 --> 绑定异常向量表 --> 初始化寄存器（禁止所有中断 --> 选择中断类型 --> 清除VICnADDR寄存器） 即：中断控制器初始化
					绑定中断处理函数
		中断发生时：	异常向量表处进入相应中断函数（一般都是汇编） --> 进入中断处理函数 --> 寻找中断发生的中断号 --> 读取相应中断处理函数地址 --> 执行isr
	  第4步绑定isr地址到VICnVECTADDR和第五步中断发生时第二阶段的第二阶段如何获取isr地址，这两步是相关的。这两个的结合技术，就是210的硬件自动寻找isr的机制。

1.8.9 S5PV210中断处理的编程实践
	1）什么是外部中断？数据手册在哪里？
		1、 SoC支持的中断类型中有一种叫外部中断。内部中断就是指的中断源来自于SoC内部（一般是内部外设），譬如串口、sing使其等部件产生的中断；外部中断时SoC外部设备，通过外部中断对应的GPIO引脚产生的中断。

		2、 按键在SoC中就是用外部中断来实现。具体实现方法是：将案件电路接在外部中断的GPIO上，然后将GPIO配置为外部中断模式。此时人通过按按键改变按键电路的电压高低，这个电压高低会触发对应的外部中断，通过引脚传出去给CPU处理。

		3、 外部中断在GPIO中的 2.60

	2）电平触发和边沿触发
		电平触发：GPIO上的电平只要满足条件，就会不听的触发中断。电平触发分两种：高电平触发、低电平触发。特点是：只要电平满足条件就会不停触发

		边沿触发：上升沿触发、下降沿触发、双边沿触发三种。边沿触发不关心电平常规状态，只关心电平触发的瞬间（边沿触发不关心电平本身是高还是低，只关心变化时从高到低还是从低到高的过程）。

		按键的工作：按键按下、或者弹起的这两个事件，那么应该用边沿触发；如果关注
	3）关键寄存器：CON、PEND、MASK
		1、 外部中断的主要配置寄存器有3个：EXT_CON、EXT_PEND、EXT_MASK
			EXT_CON：配置外部中断的触发方式。触发方式就是说外部电平怎么变化就能触发中断，也就是说这个外部中断产生的条件是什么。

			EXT_PEND：中断挂起寄存器。这个寄存器中每一位对应一个外部中断，平时没有中断时值为0，当发生中断后，硬件会自动将这个寄存器中该中断对应的位置1，
			我们处理完这个中断后应手工将该位置0。这个PEND寄存器的位就相当于是一个标志，如果发生了中断但是我们暂时忙来不及去处理时，这个位一直时1（这就是挂起），知道我们有空了去处理这个中断才会手工清除（写代码清除）这个挂起位就表示中断被处理了。

			EXT_MASK:各个外部中断的使能/禁止开关。

	分析210开发板的按键对应的EINT编号：
		EINT2、EINT3、EINT16、EINT17、EINT18、EINT19

.8.10 中断方式处理按键编程实践
	1）外部中断对应的GPIO模式设置
		1、 

	2）中断触发模式设置
		1、

	3）中断允许、清挂起
		1、
		
	4）中断处理程序isr编写

	5）总结对比：轮训方式处理按键和中断方式方式差异


1.9.1 什么是定时器（Timer）
	1）定时器是SoC中常见外设
		1、 定时器与计数器。计数器是用来计数的（每隔一个固定时间会记一个数）；因为计数器的技术时间是固定的，因此到了一定时间只要用计数值 * 技术时间周期，就得到一个时间段，这个时间段就是我们定的时间（定时器）。
		2、 定时器/计数器作为SoC的外设，主要用来实现定时执行代码的功能。定时器相对于SoC来说，就好像闹钟相对于人来说意义一样。

	2）定时器有什么用
		1、 定时器可以让SoC在执行主程序的同时，可以（通过定时器）具有计时功能，到了一定时间（计时结束）后，定时器会产生中断提醒CPU，CPU会去处理中断并执行定时器的ISR。从而去执行预先设定好的事件。

		2、 定时器就好像CPU的秘书，主要帮助CPU来计时，到时间后提醒CPU要做某件事。所以CPU有了定时器之后，只需要预先把自己xx时间之后必须要做的事情绑定到定时器中断ISR即可，到了时间之后定时器就会以中断的方式提醒CPU来处理这个事情。

	3）定时器的原理
		1、 定时器计时其实是通过计数来实现的。定时器内部有一个计数器，这个计数器根据一个时钟（这个时钟源来自于ARM的APB总线，然后经过时钟模块内部的分频器来分频得到）来工作。每个一个时钟周期，计数器就计数一次，定时器的时间就是计数器计数值 * 时钟周期。

		2、 定时器内部有1个寄存器TCNT，计数开始时我们会把一个总的计数值（譬如说300）放入TCNT寄存器中，然后每隔一个时钟周期（假设为1ms）TCNT中的值会自动减1（硬件自动完成，不需要CPU软件去干预），直到TCNT中减为0的时候，TCNT就会触发定时器中断。

		3、 定时时间是由两个东西决定：一个是TCNT中的计数值，一个是时钟周期。

	4）定时器和看门狗、RTC、蜂鸣器的关系
		1、 这几个都是和时间有关的部件。
		2、 看门狗其实就是一个定时器，只不过定时时间到了之后不只是中断，还可以复位CPU。
		3、 RTC是实时时钟，他和定时器的差别就好像闹钟（定时器）和钟表（RTC）的差别一样。
		4、 蜂鸣器是一个发生设备，在ARM里面蜂鸣器是用定时器模块来驱动的。

1.9.2 S5PV210中的定时器
	在S5PV210内部，一共有4类定时器件。这4类定时器件的功能、特征不同。

	1）PWM定时器
		1、 这种是最常见的，平时所说的定时器一般指的是这个。像简单单片机（譬如21单片机）中的定时器也是这类。
		2、 为什么叫PWM定时器，因为一般SoC中产生PWM信号都是靠这个定时器模块的。

	2）系统定时器
		1、 系统（指的是操作系统）定时器，系统定时器也是用来产生固定时间间隔（TCNT * 时钟周期）信号的，称为systick，这个systick用来给操作系统提供tick信号。
		2、 产生systick作为操作系统的时间片（time slice）的。
		3、 一般做操作系统移植的时候，这里不会由我们自己来做，一般原厂提供的基础移植部分就已经包含了，所以这里很少研究。

	3）看门狗定时器
		1、 看门狗定时器本质上也是一个定时器，和上面2个没有任何本质区别。
		2、 看门狗定时器可以设置在实践到了的时候产生中断，也可以选择发出信号复位CPU。
		3、 看门狗定时器在实践中应用很多，尤其是工业领域（环境复杂、干扰多）机器容易出问题，而且出问题后果很严重，此时一般都会用看门狗来进行系统复位。

	4）实时时钟RTC（real time clock）
		1、 区分时间段和时间点。时间段是相对的，两个时间点相减就会得到一个时间段；而时间点是绝对的，是绝无仅有的一个时间点。
		2、 定时器关注的事时间段（而不是时间点），定时器计时从开始定时器的那一刻开始，到定的时间段结束为止产生中断；RTC中工作用的是时间点（xx年xx月xx日x时x分x秒）。
		3、 RTC和定时器的区别，就相当于钟表和闹钟的区别。

1.9.3 S5PV210的PWM定时器1
	1）为什么叫PWM定时器（PWM:PULSE WIDTH MODULATION TIMER）
		1、 叫定时器说明它的本质上的原理是定时器。
		2、 叫PWM定时器，是因为这个定时器天然是用来产生PWM波形的。
	2）PWM定时器介绍
		1、 210有5个定时器。其中0、1、2、3各自对应一个外部的GPIO，可以通过这些对应的GPIO产生PWM波形信号并输出；timer4没有对应的外部GPIO（因此不是为了生成PWM波形而是为了产生内部定时器中断而生成的）。
		2、 210的5个PWM定时器的时钟源为PCLK_PSYS，timer0和timer1共同使用一个预分频器，timer2、timer3、timer4共同用一个预分频器；每个timer有一个专用的独立分频器；预分频器和分频器构成了2级分频系统，将PCLK_PSYS两级分频后生成的时钟供给timer模块作为时钟周期。

	3）S5PV210的PWM定时器框图简介
		关键点：时钟源、预分频器、

1.9.4 S5PV210的PWM定时器2
	1）预分频器和分频器
		1、 两级分频是串联（级联）的，所以两级分频的分频数是相乘的。
		2、 两级分频的分频系数在TCFG0和TCFG1寄存器中设置的。
		3、 预分频器有2个，prescaler0位timer0&timer1共用；prescaler1位timer2、3、4共用；两个prescaler范围为0~255；所以预分频器的分频值为 1~256.
		4、 分频器实质上是一个MUX开关，多选一开关决定了走哪个分频系数路线。可选择的有 1/1 1/2 1/4 1/8 1/16等。
		5、 所以最大分频为：1/4096 最小为：1/2
		6、 在PCLK_PSYS位 66MHz情况下，两次分频后的时钟周期在：0.03us -- 62.061us，再结合TCNTB的值最大可到 72小时。

	2）TCNT&TCMP、TCNTB&TCMPB、TCNTO
		1、 TCNT和TCNTB是相对应的，TCNTB是由地址的寄存器，供程序员操作；TCNT在内部和TCNTB相对应，他没有寄存器地址，程序员不能编程访问这个寄存器。
		2、 TCNT寄存器的功能就是用来减1的，它是内部的不能读写；我们想TCNT中写要通过TCNTB网进写；读取TCNT寄存器中的值要通过读取对应的TCNTO寄存器。
		3、 工作流程是：实现算好TCNT中开始减的数（譬如300），然后将之写入TCNTB寄存器中，在启动timer前，将TCNTB中的值刷到TCNT寄存器中（有一位寄存器专门用来操作刷数据过去的），刷过去后就可以启动定时器开始计时；在计时过程中如果想知道TCNT寄存器中的值减到多少了，可以读取相应的TCNTO寄存器来得知。

	3）自动重载和双缓冲（auto-reload and double buffering）
		1、 定时器工作的时候一次定时算一个工作循环。定时器默认是单个循环工作的，也就是说定是一次，计时一次，到期中断一次就完了。下次如果还要再定时中断，需要另外设置。
		2、 但是现实中用定时器来做的时候往往是循环的，最简单最笨的方法就是写代码反复重置定时器寄存器的值（在每次中断处理的isr中再次给TCNTB中赋值，再次刷到TCNT中再次启动定时器），早期的单片机定时器就是这样的；但是现在的的高级的SoC中的定时器已经默认内置了这种循环定时器工作模式，就叫自动装载（auto-reload）机制。
		3、 自动装在机制就是当定时器初始化好开始几时候再不用管了，他一个人周期到了后自己从TCNTB中再次装载值到TCNT中，再次启动定时器开始下个循环。
		4、 定时功能只需要；TCNT、TCNTB两个即可；TCNTO寄存器用来做一些捕获计时；TCMPB用来生成PWM波形。

1.9.5 S5PV210的PWM定时器3
	1）什么是PWM？
		1、 PWM:PULSE WIDTH MODULATION TIMER，脉宽调制
		2、 PWM波形是周期性波形，周期为T。
		3、 占空比：高电平/周期

	2）PWM波形的生成原理
		1、 PWM波形其实就是用时间控制电平高低，所以用定时器来实现PWM波形是天经地义的。
		2、 定时T*duty，时间到了在isr中拉高GPIO，然后定时T*(1-duty)，时间到了在isr中拉低GPIO。...
		3、 210中，PWM波形产生有2个寄存器很关键，一个是TCNTB、一个是TCMPB。其中，TCNTB决定了PWM波形的周期，TCMPB决定了PWM波形的占空比。最生成的周期是:TCNTB * 时钟周期（PCLK_PSYS经过两级分频后得到的时钟周期）。
		4、 最终生成的PWM波形的占空比是：TCMPB/TCNTB 

	3）输出电平翻转器
		1、 PWM定时器可以规定规定：当TCNT>TCMP是为高电平，当TCNT<TCMP时为低电平；可以可以规定：当TCNT>TCMP是为低电平，当TCNT<TCMP时为高电平
		2、 基于上面讲的，当duty从30% --> 70%时，我们TCMPB寄存器中的值就要改（譬如TCNTB中是300时，TCMPB就要从210 --> 90）。这样的改变可以满足需要，但是计算有点麻烦。于是乎210的PWM定时器帮我们提供了一个友好的工具叫做电平翻转器。
		3、 电平翻转器在电路上的实质就是一个电平取反的部件，在编程上体现为一个寄存器位。写0就关闭输出电平翻转，写1就是开启输出电平翻转。开启后和开启前输出电平刚好翻转。（输出电平一翻转30%的duty就变成70%了）。
		4、 实践中到底是TCNTB和TCMPB谁大谁小是高电平还是低电平，一般不用理论分析，只要写个代码然后用示波器看一下出来的波形就知道了；如果犯了就直接开启电平翻转器即可。

	4）死区生成器
		1、 PWM有一个应用就是应用在功率电路中用来对交流电压进行整流。整流时两路整流分别在正点平和副电瓶时导通工作，不能同时导通（同时导通会直接短路，瞬间都会导致电路烧毁）。大功率的开关电源广泛使用了整流技术。特别是逆变器，用SoC的GPIO输出的PWM波形来分别驱动2路整流的IGBT。
		2、 PWM波形用来做整流时要求不能同时高或低，因为会短路。但是实际电路是不理想的，不可能同时上升/下降沿，所以比较安全的做法是留死区。
		3、 死区这东西离不了也多不了。死区烧了容易短路，死区多了控制精度低了不利于产品性能的提升。
		4、 210提供了自带的死区生成器，只要开启死区生成器，生产出来的PWM波形就自带了死区控制功能，用户不用再自己去操心死区问题。
		5、 大部分人工作是用不到这个的，直接关掉死区生成器即可。

1.9.6 蜂鸣器和PWM定时器编程实践1
	1）封面去的工作原理
		1、 蜂蜜器中有两个片，离得很近但没挨着；没电的时候弹片本身张丽作用下分开彼此平行；优点的时候分别充电，在+ -相吸的作用下挨着，快速切换产生声音。
		2、 频率高低会影响音频，一般音频越低声音听起来越低沉、音频越高听起来越尖锐。
		3、 只要用PWM的电压信号来驱动蜂鸣器，吧PWM波形的周期T设置为要发出的声音信号的1/频率即可；PWM的占空比只要确保能驱动蜂鸣器即可（驱动能力问题，一般引脚驱动能力都不够，所以蜂鸣器会额外用三极管来放大电流来供电）。

	2）原理图和硬件信息
		1、 查阅原理图可知，开发板地板上的蜂鸣器通过通过GPD0_2 （XpwmTOUT2）引脚连接在SoC上。
		2、 GPD0_2通过限流电阻接在三极管的基级上，引脚有点蜂蜜器就会有点（三极管导通）；引脚没电蜂蜜器就会没电（三极管关闭）。这些都是硬件问题，软件工程师不用管，软件工程师只要写程序控制GPD0_2引脚的电平产生PWM波形即可。

		3、 GPD0CON : 0xE02000A0，bit[8-11] : 0b0010（功能选择为 TOUT_2，就是把这个引脚设置为PWM输出功能）
		4、 从GPD0_2引脚可以反推出使用的事timer2定时器。

	3）PWM定时器的主要寄存器详解
		1、 相关的寄存器有TCFG0、TCFG1、CON、TCNT2、TCMP2、TCNTO2

1.9.10 看门狗定时器
	1）什么是看门狗、有什么用
		1、 ...
		2、 实践中一般使用外置看门狗。

	2）210看门狗定时器的结构框图

	3）看门狗定时器的主要寄存器
		WTCON WTDAT WTCNT WTCLRINT

1.9.10 实时时钟RTC 
	1）何为实时时钟
		1、 real time clock，真实时间，就是所谓的xx年xx月xx日x时x分x秒
		2、 RTC是SoC中一个内部外设，RTC有自己独立的晶振提供RTC时钟源（32.768KHz），内部有一些寄存器用来记录时间（年月日时分秒）。一般情况下为了在系统关机时间仍然在工作，还会给RTC提供一个电池供电。

	2）210实时时钟的结构框图
		1、 时间寄存器7个
		2、 闹钟发生器

	3）闹钟发生器
		1、 可以定闹钟时间，到时见产生RTC alarm interrupt，通知系统闹钟定时到了。
		2、 注意闹钟定时定的是时间点，中断定的是时间段。

	4）210实时时钟的主要寄存器
		1、 INTP 中断挂起寄存器
		2、 RTCCON	RTC控制寄存器
		3、 RTCALM ALMxxx 	闹钟功能相关寄存器
		4、 BCMxxx 	时间寄存器

	5）BCD码
		1、 RTC中所有的时间（年月日时分秒星期，包括闹钟）都是用BCD码编码的
		2、 BCD码本质上是对数字的一种编码。用来解决这种问题：由56得到0x56（或者反过来）。也就是说我们希望十进制的56可以被编码成56（这里不是十进制56，而是两个数字5和6）。
		3、 BCD码的作用在于可以将十进制数拆成组成这个十进制数的各个数字的编码，贬称编码后就没有位数限制的了。譬如有1个很大的数 1234567898765432123456789 ，如果这个数纯粹当数字肯定超出了int的范围，计算机无法直接处理。要想让计算机处理这个数，计算机首先的能表达这个数，表达的方式就是先把这个数转成对应的BCD码（1234567898765432123456789）。
		4、 BCD码在计算机中可以用十六进制的形式表示。也就是说十进制的56转成BCD码后是56，在计算机中用0x56来表达（暂时存储于运算）。
		5、 需要写2个函数，一个是bcd转十进制，一个是十进制转bcd。当我们要设置时间时（譬如要设置位23分），我们需要将这个23转成0x23然后在赋值给相应的寄存器 BCDMIN；当我们从寄存器中读取一个时间时（譬如读取到的事0x59），需要将只当做BCD码转成十进制再去显示（0x59当做BCD码就是59，转成十进制就是59，所以显示就是59）。


1.9.11 RTC编程实践
	1）设置实践与读取显示实践
		1、 为了安全，默认情况下RTC读写是禁止的，此时写RTC时间是不允许的。当我们要更改RTC时间时需要先打开RTC的读写开关，然后再进行读写操作，最后关闭读写开关。
		2、 读写RTC寄存器时，一定要注意BCD码和十进制的转换
		3、 年的问题。BCDYEAR寄存器存的并不是完整的年数（例如2020）而是基于2000年的偏移量来存储的，所以存的是 15.


1.10.1 主流的外村设备介绍
	1）主流的外存设备介绍
		1、 内存和外存的区别：一般是把RAM（Random Access Memory,随机访问存储器，特点是任意字节读写，掉电丢失）叫内存，把ROM（Read only Memory,只读存储，类似于Flash SD卡之类，用来存储东西，掉电不丢失，不能随机地址访问，只能以块为单位来访问）叫外存。

	2）软盘、硬盘、光盘、CD、磁带
		1、 存储原理大部分为磁存储，缺点是读写速度、可靠性等。优点是技术成熟、价格低。广泛使用在桌面电脑中，在嵌入式设备中几乎无使用。
		2、 现代存储的发展方向是Flash存储，闪存技术是利用电学原理来存储1和0，从而制成存储设备。所以闪存设备没有物理运动（硬盘中的磁头），所以读写速度可以很快，且无物理损耗。

	3） 纯粹的Flash：NandFlash、NorFlash
		1、 最早出现的、最原始的Flash颗粒组成的芯片。也就是说NandFlash、NorFlash芯片中只是对存储单元做了最基本的读写接口，然后要求外部的SoC来提供Flash读写的控制器以和Flash进行读写时序。
		2、 缺陷：1、 读写接口时序比较复杂。2、 内部无坏块处理机制，需要SoC自己来管理Flash的坏块；3、 各家厂家的Flash接口不一致，甚至同一个厂家的不同型号、系列的Flash都不一致，这就造成了产品升级时很麻烦。
		3、 NandFlash分：MLC和SLC两种。SLC技术比较早，可靠性高，缺点是容量做不大（或者说容量大了太贵，一般SLC Namd都是512MB以下）；MLC技术比较新，不成熟，可靠性差，优点是容量可以做很大很便宜，现在基本都在发展MLC技术。

	4）SD卡、MMC、MicroSD、TF卡
		1、 这些卡其实内部就是Flash存储颗粒，比直接的Nand芯片多了统一的外部封装和接口。
		2、 卡都有统一的标准，譬如SD卡都是遵守SD卡规范来发布的。这些规范规定了SD卡的读写速度、读写接口时序、读写命令集、卡大小尺寸、引脚个数定义。这样做的好处就是不同厂家的SD卡可以通用。

	5）iNand、NoviNand、eSSD
		1、 电子产品如手机、相机等，前些年趋势是用SD卡/TF卡等扩展存储容量；但是近些年的趋势是直接内置大容量Flash芯片而不是外部扩展卡。
		2、 外部扩展卡时间长了卡槽可能会接触不良导致不可靠。
		3、 现在主流的发展方向是使用 iNand、NoviNand、eSSD （还有别的一些名字）来做电子产品的存储芯片。这些东西的本质还是NandFlash，内部有Nand的存储颗粒构成，在集成了块设备管理单元，综合了SD卡为代表的各种卡的优势和原始的NandFlash芯片的优势。
		4、 优势：1、向SD卡学习，有统一的标准（包括引脚定义、物理封装、接口时序）。 2、 向原始的Nand学习，以芯片的方式来发布而不是以卡的方式；3、 内置了Flash管理模块，提供了诸如坏块管理，让Nand的管理容易了起来。

	6）SSD（固态硬盘）


1.10.2 SD卡的特点和背景知识
	1）SD卡和MMC卡的关系
		1、 MMC标准比SD标准更早，SD标准兼容MMC标准。
		2、 MMC卡可以被SD读卡器读写，而SD卡不可以被MMC读卡器读写。

	2）SD卡和Nand、Nor等Flash芯片差异
		1、 SD卡或者mmc卡等卡类有统一的标准，而Nand芯片没有统一的标准（各家产品会有差异）

	3）SD卡与MicroSD的区别
		1、 体系大小区别而已，传输与原理完全相同。

	4）SD卡与TF卡的区别
		1、 外观上，SD卡大而TF卡小；用途上，SD卡用于数码相机等而TF卡广泛用于手机、GPS等。
		2、 时间上，SD卡1999年推出，TF卡与2004年推出；SD卡由日本松下、东芝与美国SanDisk共同推出，而TF卡由Motorola与SanDisk共同推出。
		3、 SD卡由写保护而TF卡没有，TF卡可以通过卡套转成SD卡使用。

1.10.3 SD卡的编程接口
	1）SD卡的物理接口
		1、 SD卡由9个针脚与外界进行物理连接，这9个脚中有2个地，1个电源，6个信号线。

	2）SD卡协议与SPI协议
		1、 SD卡与SRAM/DDR/SROM之类的东西的不同：SRAM/DDR/SROM之类的存储芯片是总线式的，只要连接上初始化好之后就可以由SoC直接以地址方式来访问；但是SD卡不同通过接口给地址来访问，它的访问需要按照胰岛功能的接口协议（时序）来访问。
		2、 SD卡虽然只有一种物理接口，但是却支持两种读写协议：SD协议和SPI协议。

	3）SPI协议特点（低速、接口操作时序简单、适合单片机）
		1、 SPI协议是单片机中广泛使用的一种通信协议，并不是为SD卡专门发明的。
		2、 SPI协议相对SD协议来说速度较低。
		3、 SD卡支持SPI协议，就是为了单片机方便使用。

	4、 SD协议特点（高速、接口时序复杂，适合有SDIO接口的SoC）
		1、 SD协议是专门用来和SD卡通信的。
		2、 SD协议要求SoC中有SD控制器，运行在高速率下，要求SoC的主频不能太低。

	5）210的SD/MMC控制器
		1、 数据手册Section8.7，为SD/MMC控制器介绍。
		2、 SD卡内部除了存储单元Flash外，还有SD卡管理模块，我们SoC和SD卡通信时，通过9帧引脚以SD协议/SPI协议向SD卡管理模块发送命令、时钟、数据等信息，然后从SD卡返回信息给SoC来交互。工作时每一个任务（譬如初始化SD卡、读一个块、写、擦除...）都需要一定的时序来完成（所谓时序就是先向SD卡发送xx命令，SD卡会xx消息，然后再向SD卡发送xx命令...）。

1.10.4 S5PV210的SD卡启动详解1
	1）SoC为何要支持SD卡启动
		1、 一个普遍性原则就是：SoC支持的启动方式越多，将来使用时就越方便，用户的可选择性就越大，SoC的适用面就越广。
		2、 SD卡启动有一些好处：譬如可以再不借用专用的烧录工具（类似Jlink）的情况下对SD卡刷机，然后刷机后的SD卡插入卡槽，SoC即可启动；譬如可以用SD卡进行量产刷机（量产卡）。像X210开发板，板子贴片好的时候，内部iNand是空的，此时直接启动无反应；班子出厂前官方刷机时是把视线做好的量产卡插入SD卡卡槽，然后达到iNand方式启动；因为此时iNand是空的，所以第一启动失败，会转为第二启动，就从外部SD2通道的SD卡启动。启动后会执行刷机操作对iNand进行刷机，刷机完成后自动重启（这回重启时iNand中已经有image了，所以可以启动了）。刷机完成后SD量产卡拔掉，烧机48小时，无司机即可装箱待发货。

	2）SD卡启动的难点在哪里（SRAM、DDR、SDCard）
		1、 SRAM、DDR都是总线式访问的，SRAM不需要初始化即可直接使用而DDR需要初始化后才能使用，但是总之CPU可以直接去SRAM/DRAM打交道；而SD卡需要时序访问，CPU不能直接和SD卡打交道。NorFlash读取可以总线式访问，所以NorFlash启动非常简单，可以直接启动，但是SD/NandFlash不行。
		2、 以前只有NorFlash可以作为启动介质，台式机笔记本的BIOS就是NorFlash做的。后再三星在2440中使用了SteppingStore的技术，让NandFlash也可以作为启动介质。 SteppingStore（启动基石）技术就是在SoC内部内置4KB的SRAM，然后开机时SoC根据OMpin判断用户设置的启动方式，如果是NandFlash启动，则SoC的启动，部分的硬件直接从外部NandFlash中读取开头的4KB到内部的SRAM作为启动内容。
		3、 启动基石技术进一步发展，在6410芯片中得到完善，在210芯片是已经完全成熟。210中有96KB的SRAM，并且有一段iROM代码作为BL0,BL0再去启动BL1（210中的BL0做的事情在2440中也有，只不过那时候是硬件自动完成的，而且体系没有210中这么详细）。

	3）S5PV210的启动过程回顾
		1、 210启动首先执行内部的iROM（月就是BL0），BL0会判断OMpin来决定从哪个设备启动，如果启动设备是SD卡，则BL0会从SD卡读取前16KB（不一定是16，但16可以工作）到SRAM中去启动执行（这部分就是BL1，这就是steppingstone技术）
		2、 BL1执行之后剩下的就是软件的事情了，SoC就不用再去操心了。

	4）SD卡启动流程（bin文件小于16KB和大于16KB时）
		1、 启动的第一种情况是整个镜像大小小于6KB。这时候相当于我的整个镜像作为BL1被steppingstone直接硬件加载执行了而已。
		2、 启动的第二种情况就是真个镜像大小大于16KB。（只要大于16KB，就一样）这时候就要把整个镜像分为2部分；第一部分16KB大小，第二部分是剩下的大小。
		3、 然后第一部分作为BL1启动，负责去初始化DRAM并且将第二部分加载到DRAM中去执行（uboot就是这样做的）

	5、 最重要的但是隐含未讲的东西
		1、 问题：iROM究竟是怎么读取SD卡/NandFlash的？
			三星在iROM中实先内置了一些代码区初始化外部SD卡/NandFlash，并且内置了读取各种SD卡/NandFlash的代码在iROM中。BL0执行时就是通过调用这些device copy function来读取外部SD卡/NandFlash的中的BL1的。


1.10.5 S5PV210的SD卡启动详解2
	1）SoC支持SD卡启动的秘密（iROM代码）
		1、 三星系列SoC支持SD卡/NandFlash启动，主要依靠steppingstone技术，具体S5PV210中支持steppingstone技术的事内部的iROM代码。

	2）再看iROM application note: block device copy function 

	3）扇区和块的概念
		1、 早期的块设备就是软盘硬盘这列磁存储设备，这种设备的存储单元不是以字节为单位，而是以扇区为单位。磁存储设备读写的最小单元就是扇区，不能只读取或写部分扇区。这个限制是磁存储设备本身物理方面的原因造成的，也称为了我们编程时必须遵守的规律。
		2、 一个扇区有好多个字节（一般是512个字节）。早期的磁盘扇区是512字节，实际上后来的磁盘扇区可以做的比较大（譬如1024字节，2048字节，4096字节），但是因为原来最早是512字节，很多的软件（包括操作系统和文件系统）已经默认了512这个数字，因此后来的硬盘虽然物理上可能支持更大的扇区，但是实际上一般还是兼容512字节扇区这种操作方法。
		3、 一个扇区可以看成是一个块（块的概念就是：不是一个字节，十多个字节组成一个共同的操作单元），所以就把这一类的设备称为块设备。常见的块设备有：磁存储设备硬盘、软盘、DVD和Flash设备（U盘、SSD、SD卡、NandFlash、NorFlash、emmc、iNand））
		4、 Linux里面有个mtd驱动，就是用来管理这类块设备的。
		5、 磁盘和Flash以块为单位来读写，就决定了我们启动时 device function 只能以整块为单位来读取SD卡。

	4）用函数指针的方式调用 device copy function 
		1、 宏定义方式来调用。好处是简单方便，坏处是编译器不能帮我们做参数的静态检查。
		2、 函数指针方式来调用。

1.10.6 S5PV210的SD卡启动实战 
	1）任务：大于16KB的bin文件使用SD卡启动
		1、 总体思路：将我们的代码分为2部分：第一部分BL1为小于等于16KB，第二部分为任意大小，iROMdiamante执行完后从SD卡启动会自动读取BL1到SRAM中执行；BL1执行时负责初始化DDR，然后手动将BL2从SD卡copy到DDR中正确位置，然后BL1元跳转到BL2中执行BL2。

		2、 细节1：程序怎么安排？
			程序整个分为2个文件夹BL1和BL2，各自管理各自的项目。
		3、 细节2：BL1中要完成：关看门狗、设置栈、开/关iCache、供电锁存、初始化DDR、从SD卡赋值BL2到DDR中特定位置、远跳转执行BL2。
		4、 细节3：BL1在SD卡中必须从block1开始（block0不能用，这个是三星官方规定的），长度为16KB内，此处暂定16KB（也就是32个block）；BL1理论上可以从33扇区开始，但是实际上为了安全都会留一些空扇区作为隔离，譬如可以从45扇区开始，长度由自己定（十几根据自己的BL2大小来分配长度。
		5、 细节4：DDR初始化好之后，整个DDR都可以使用了，这时在其中选择一段长度足够BL2的DDR空间即可。我们选择 0x23E00000 (因为BL1中只初始化了DDR1，地址空间范围是 0x20000000 -- 0x2FFFFFFF)。

	2）代码分为2部分（BL1和BL2）

	3） BL1中的重定位

	4）BL2远跳转
		1、 因为我们BL1和BL2其实是2个独立的程序，连接时也是独立分开连接的，所以不能像以前一样使用 ldr pc, =main 这种方式来通过连接地址实现远眺转到BL2。
		2、 我们的解决方案是使用地址进行强制跳转。因为我们知道BL2在内存地址0x23E00000处，所以直接去执行这个地址即可。

1.10.7 210的SD卡启动实践2
	1）烧录实验

	2）代码分为2部分启动的缺陷
		1、 代码分为2部分，这种技术叫分散加载。这种分散加载的方法可以解决问题，但是比较麻烦。
		2、 分散加载的缺陷：一、代码完全分2部分，完全独立，代码编写和组织上麻烦；二、无法让工程项目兼容SD卡启动和Nand启动、NorFlash启动等各种启动方式。

	3）uboot中的做法
		1、 第二种思路：程序仍然包括BL1和BL2两部分，但是组织形式上部分为2部分而是作为一个整体组织。它的实现方式是：iROM启动然后从SD卡的扇区1开始读取16KB的BL1然后去执行BL2，BL1负责初始化DDR，然后从SD卡中读取整个程序（BL1+BL2）到DDR中，然后去DDR中执行（ldr pc, =main 这种方式远眺转从SRAM中的BL1跳转到DDR中的运行的BL2）。

	4）再来分析uboot的SD卡启动细节
		1、 uboot编译好之后又200多KB，超出了16KB。uboot的组织方式就是前16KB为BL1，剩下的部分为BL2。
		2、 uboot烧录到SD卡的时候，先截取uboot.bin的前16KB（实际脚本截取的事8KB）烧录道SD卡的block1 -- block32；然后将整个uboot烧录到SD卡的某个扇区中（譬如49扇区）
		3、 实际uboot从SD卡启动时是这样的：iROM先执行，根据 OMpin 判断出启动设备是SD卡，然后从SD卡的block1开始读取16KB（8KB）到SRAM中执行BL1，BL1执行时负责初始化DDR，并且从SD卡的49扇区开始复制整个uboot到DDR中指定的位置（0x23E00000）去备用；然后BL1继续执行知道ldr pc,  =main 时BL1跳转到DDR上的BL2中接着执行uboot的第二阶段。

		总结：uboot中的这种启动方式比上节讲的分散加载的好处在于：能够兼容各种启动方式。


1.10.8 解决x210开发板的软件开关按键问题
	1）x210开发板的软启动电路详解
		1、 210供电需要的电压比较稳定，而外部适配器的输出电压不一定那么稳定，因此板载了一个稳压器件 MP1482，这个稳压芯片的作用就是外部适配器电压爱一定范围变化时稳压芯片的输出电压都是5V
		2、MP1482芯片有一个EN（enable）引脚，这个引脚可以让稳压芯片输出或关闭输出。EN为高电平时有输出电压，EN引脚为低电平时稳压芯片无输出。
		3、 亮个因素可以影响EN引脚的电平：第一个是POWER按键（SW1），按下则EN为高，弹起则EN为低；第二个事POWER_LOCK（EINT0）引脚，这个引脚POWER_LOCK模式下高电平，则EN为高；若这个引脚为EINT0模式或者为POWER_LOCK模式单输出为低电平，则EN为低。
		4、 图中的EINT1引脚，这个引脚的作用是用来做中断，提供给CPU用来唤醒的。

	2）为什么要软启动
		1、 一般的电路设计都是用拨码开关来做电源的（达到一侧册接通，达到另一侧则关闭）。这种方式的优点是设计简单，缺点是电路太简单，整个主板要么有电要么无电，无法做休眠模式、低功耗模式等。
		2、 软启动的电路是比较接近实际产品的，其他开发板的硬件开关其实是简化版的，和实际产品还有差异。

	3）开发板供电锁存原理和分析
		1、 软开关在设计时有一个置锁电路，用EINT0（也就是GPH0_0）引脚来控制的。
		2、 EINT0这个引脚是复用设计（两个完全不相干的功能记载同一个引脚上，同时我们只能让这个引脚用于其中一种功能，这就叫复用）的，一个是GPIO（也就是GPH0_0引脚）、一个是PS_HOLD_CONTROL。（注意：EINT0功能算是GPIO下的一个子功能）
		3、 PS_HOLD_CONTROL在section2.4 Power Management章节下的 4.10.5.8
		4、 PS_HOLD_CONTROL ： 0xE010E81C bit[0] : enable (表示用作gpio还是ps_hold);
										 bit[9] : 0表示输入，1表示输出
										 bit[8] : 0表示低，1表示高

		分析：要是用软启动置锁，则需要bit0 8 9 都置1。

1.11.1 NandFlash的接口 
	1）Nand的型号与命名
		1、 以K9F2GF08为例：K9F 表示三星公司的NandFlash系列。
					      2G   表示2Gbit即 256MB
					      08   表示Nand是8位的（8位就是8跟数据线）

		2、 Nand命令中可以知道：厂家、系列型号、容量、数据位。

	2）Nand的数据位
		1、 Nand有8位数据位的，有6位的数据位的。做电路时/写软件时应该根据自己实际采购的Nand的位数来设计电路/写软件。
		2、 说明Nand是并行接口（8/16位）
		3、 Nand的数据线上传递的不一定完全是有效数据，也可以有命令、地址等。

	3）Nand的功能框图
		1、 Nand的结构可以看成是一个矩阵式存储器，其中被分成一个一个的小块，每一个小块可以存储一个bit位，然后彼此以一定组合成整个Nand。
		2、 Nand中可以被单词访问的最小单元（就是说对Nand进行一次读写至少要读写这么多，或者是这么多的证书倍）叫做page（页），在K9F2G08芯片中，Page的大小是2KB+64B。也就是我们要读些K9F2G08，每次至少要读写2KB或者 n*2KB，及时我们只是想要其中一个字节。这就是我们说的典型的块设备（现在有些块设备为了方便，提欧共了一种random read模式，可以只读取1个字节）。
		3、 页往上还有Block（块）的概念，1个块等于若干个页（譬如K9F2G08中1个块等于64页）。
		4、 页往上就是整个Nand芯片了，较多Device。一个Device是若干个Block，譬如K9F2G08一个Device有2048个block。所以整个Device大小为：2048 * 64 * 2K = 256MB，
		5、 块设备分 Page、block有什么意义？
			首先要明白，块设备不能完全按字节访问而必须按照块访问时物理上的限制，而不是人为设置的障碍。其次，Page、Block各有各的意义，譬如Nand中：Page是读写Nand的最小单位；Block是擦除Nand的最小单位。（这是Nand的物理原理限制要求的，不是谁要这样的，所以对于我们做软件的来说，只能去想办法适应硬件，不是想着超越硬件）。

		6、 Nand芯片中主要包含2部分：Nand存储颗粒 + Nand接口电路。存储颗粒就是纯粹的Nand原理的存储单元，类似于创建仓库；Nand接口电路是用来管理存储颗粒，并且给外界提供一个统一的Nand接口规格的访问接口的。
		7、 Nand中有很多存储单元，每个单元都有自己的地址（地址是精确到字节的）。所以Nand是地址编排精确到字节，但是实际读写却只能精确到页（所以Nand的很多操作都要求给的地址是页对其的，譬如2K、4K、512K等这样的地址，不能给 300B 这样的地址）。Nand读写是地址传递是通过IO线发送的，因为地址由30位而IO只有8位，所以需要多个cycle才能发送完毕。一般的Nand都是4cysle或者5cycle发哦送给你地址的（从这里把Nand分为了4cycle Nand和5cycle Nand）。

		总结：Nand芯片内部有存储空间，并且有电路来管理这些存储空间，向外部提欧共统一的Nand接口的访问规则，然后外部的SoC可以使用Nand接口时序来读写这个Nand存储芯片。Nand接口是一种共用的接口，是一种标准，理论上来说外部SoC可以直接模拟Nand接口来读写Nand芯片。但是实际上因为Nand接口对时序要求非常严格，而且时序很复杂，所以一般的SoC都是通过专用的硬件的Nand控制器（这些控制器一般都是作为SoC的内部外设来存在的）来操控Nand芯片的。

1.11.2 NandFlash的结构
	1）Nand的单元组织：block与page（大页Nand与小页Nand）
		1、 Nand的页和以前讲过的块设备（尤其是硬盘）的扇区是类似的。扇区最早在磁盘中是512字节，后来也有些高级的硬盘扇区不是512字节而是1024字节/2048字节/4096字节等。Nand也是一样，不同的Nand的页大大小是不同的，也有512字节/1024字节/2048字节/4096字节等。
		2、 一个block等于多少page也不是一定的，不同的Nand也不同。一个Nand芯片有多少block也不是一定的，不同的Nand芯片也不同。

		总结：Nand的组织架构挺乱的，接口时序也不同，造成结果就是不同厂家的Nand芯片，或者是同一个厂家的不同系列型号存储容量的Nand接口也不一样。所以Nand有一个很大的问题就是一但升级容量或者换芯片系列硬件重新做、软件要重新移植。

	2）带内数据和带外数据（ECC与坏块标记）
		1、 Nand的每个页有两部分组成，这两部分各自都有过一定的存储空间。譬如K9F2G08中为2K+64字节。其中的2K字节属于带内数据，是我儿们真正的存储空间，将来存储在Nand中的有效数据就是存在这2K范围内的（我们平时计算Nand的容量时也是只考虑这2KB）；64字节的带歪数据不能用来存储有效数据，是作为别的附加用途的（譬如用来存储ECC数据、用来存储坏块标志等...）。
		2、 什么是ECC：（error correction code，错误校验码）。因为Nand存储本身出错（为反转）概率高（Nand较Nor最大的确定啊就是稳定性低），所以当我们将有效数据存储到Nand中时都会同时按照一定算法计算一个ECC信息（譬如CRC16等校验算法），将ECC信息同时存储到Nand这个页的带外数据区。然后等将来读取数据时，对数据用同样的算法在计算一次ECC，并且从带歪数据区读出的ECC进行校验。如果校验通过则证明Nand的有效数据可信，如果校验不通过则证明这个数据已经损坏（只能丢弃或者尝试修复）。
		3、 坏块标志：Nand芯片用一段时间后，可能某些块会坏掉（这些块无法擦除，或者无法读写了），Nand的坏块非常类似于硬盘的坏道。坏块是不可避免的，而且随着Nand的使用坏块会越来越多。当坏块还不算太多时这个Nand都是可以用的，除非坏块太多了不划算了才会换新的。所以我们为了管理Nand发明了一种坏块标志。Nand的每个页的64字节的带外数据中，我们（一般是文件系统）定义一个固定位置（譬如定位低24字节）来标记这个块是好的还是坏的。文件系统在发现这个块已经坏了没法养乐时会将这个块标记为坏块，以后访问时忽略这个块。

	3）Nand的地址时序
		1、 Nand的地址有多位，分4/5周期通过IO引脚发送给Nand进行寻址。殉职的最小单位是字节，但是读写最小单位是页。
		2、 Nand的地址在写代码时要按照Nand要求的时序和顺序依次写入。

	4）Nand的命令码
		1、 外部要想通过Nand控制器访问Nand（实质就是通过Nand接口），就必须按照Nand接口给Nand发送命令、地址、数据等信息来读写Nand。
		2、 Nand芯片内部的管理电路本身可以接受外部发送的命令，然后分局这些命令来读写Nand内容与外部SoC交互。所以我们对Nand进行的所有操作（擦除、读、写...）都要有命令、地址、数据的参与才能完成，而且必须按照Nand芯片规定的流程来做。

1.11.3 NandFlash的常见操作及流程分析
	1）坏块检查
		1、 Flash使用之前要先同意擦除（擦除的单位就是块）。Flash类设备擦除后里面全是1，所以擦干净之后读出来的值是0xff。
		2、 价差坏块的思路：先擦除，然后将整块读出来，一次检测各字节是否为0xff，如果是则表明不是坏块，如果不是则表明是坏块。
		3、 
	2）页写（program）操作
		1、 写之前确保这个页是被擦除干净的。如果不是擦除干净的（而是脏的、用过的）页，写进去的值就是错的，不是想要的结果。
		2、 写操作（write）在flash的操作中就叫编程（program）
		3、 SoC写Flash时通过命令线、IO线一次发送命令、写页地址、写数据等进入NandFlash。
		4、 写的过程：SoC通过Nand控制器和Nand芯片完成顺序对接，然后按照时序要求将一页数据发给Nand芯片内部的接口电路。接口电路现接收数据到自己的缓冲区，然后在集中吸入Nand芯片的存储区域中。Nand的接口电路将一页数据从缓冲区中写入Nand存储系统中需要一定的时间，这段时间Nand芯片不能再响应SoC发过来的其他命令，所以SoC要等Nand接口电路忙完，等待方法是SoC不断读取状态寄存器（这个状态寄存器有2中情况：一种是SoC的Nand控制器自带的，另一种是SoC通过发命令响应得到的），然后通过检查这个状态寄存器的状态位就知道Nand接口电路刚才写的那一页数据写完了没、写好了没。直到SoC受到了正确的状态寄存器响应才能认为刚才要写的那一页数据已经ok。（如果SoC收到的状态一直不对，可以考虑重写或者认为这一页所在的块已经是坏块，或者整个Nand芯片已经挂掉了）。
		5、 正常情况下到了第四步就已经完了。但是因为Nand的读写又不靠谱情况，因此我们为了安全回去做ECC校验。ECC校验有硬件式校验和软件式校验2种。软件式校验可以采用的策略有很多，其中之一（Nand芯片侧手册上推荐的方式是）：将刚才写入的1页数据读出来，和写入的内容进行逐一对比。如果读出的和写入的完全一样，说明刚才的写入过程正确完成了；如果读出来的和写入的不完全一样那就说明刚才的吸入有问题。
		6、 硬件式ECC：SoC的Nand控制器可以提供硬件式ECC（这个也是比较普遍的情况）。硬件式ECC就是在Nand的控制器中有个硬件模块专门做ECC操作。当我们操作Nand芯片时，只要按照SoC的要求按时打开ECC生成开关，则当我们写入Nand芯片时SoC的Nand控制器的ECC模块会自动生成ECC数据放在相应的寄存器中，然后我们只要将这生成的ECC数据写入Nand芯片的带歪数据区即可；在将来赌气这块Nand芯片时，同样要打开硬件ECC开关，然后开始读，在读的过程中硬件ECC会自动计算读进来的一页数据的ECC值并将之放到相应的寄存器。然后我们载读取带外数据区中原来写入时存入的ECC值，和我们刚才读的时候得到的ECC值进行校验。校验通过则说明读写正确，校验不通过则说明不正确（放弃数据或者尝试修复）。

	3）擦除（erase）操作
		1、 擦除地址必须是块对齐的地址。如果给了不对齐的地址，结果是不可知的（有些Nand芯片没关系，它内部会自动将其对其，而有些Nand会返回地址错误）。
		2、 读写时给的地址也是一样，要求是页对其地址。如果给了不对齐的，也是有可能对有可能错。

	4）页读（read）操作
		1、 同读，比写简单。

1.11.4 S5PV210的NandFlash控制器
	1）SoC的Nand控制器
		1、 Nand芯片本身通过Nand接口电路来存取数据，Nand接口电路和SoC之间通过Nand接口时序来通信。Nand接口时序相对复杂，如果要SoC完全用软件来实现Nand接口时序有一些不好（主题是：第一很难保证时序能满足、容易不稳定；第二代码很难写）。因此解决方案：在SoC内部集成一个Nand控制器（实质就是一块硬件电路，这个硬件电路完全满足Nand接口时序的操作，然后接口时序的操作寄存器化）。
		2、 SoC和Nand芯片之间通信，在SoC没有Nand控制器时需要SoC自己来处理接口时序，编程很麻烦，需要程序员看Nand芯片的接口时序图，严格按照接口时序图中编码（尤其要注意各个时间参数）；在SoC有Nand控制器时SoC只需要编程操控Nand控制器的寄存器即可，Nand控制器内部硬件会根据寄存器值来生成合适的Nand接口时序和Nand芯片通信。所以在有Nand控制器时编程简单很多，我们读写Nand芯片时再也不用关注Nand接口时序了，只要关注SoC的Nand控制器的寄存器即可。
		3、 扩展来讲，现在的技术趋势就是：几乎所有的外设在SoC内部都有对应的控制器来预期通信，那么SoC内部集成的控制器（也就是各种内部外设）越多，则SoC硬件能完成的功能越多，将来用这个SoC来完成相应任务软件编程越简单。譬如说图形处理和图像处理领域，2D图像编码（jpeg编码）、视频编码（h.264编码），现在大部分的application级别的SoC都有继承的内部编码器（像S5PV210机油、更复杂的 4418、6818就更不用说了，只会更先进），我们可以利用这些硬件编码器来进行快速的编解码，这样软件工作量和难度降低了很多（这就是所谓的硬件加速）。
	2）结构框图分析
		1、 结构框图中关键点：SFR（我们后续编程的关键，编程时就是通过读写SRF来产生Nand接口时序以读写Nand芯片的）+ Nand interface（硬件接口，将来和Nand芯片的相应引脚进行连接） + ECC生成器。

	3）S5PV210的Nand控制器的主要寄存器
		1、 NFCONF、NFCONT、NFCMMD、NFADDR、NFDATA、NFMECC&NFSECC、NFSBLK、NFSTAT

1.11.5 Nand操作代码解析
	1） 擦除函数

	2）页读取函数

	3）页写函数

	总结：
		1、 像NandFlash这类芯片，通过专用的接口时序和SoC内部的控制器相连（这种连接方式是非常普遍的，像LCD、DDR等都是类似的连接）。这种接法和射界对我们编程来说，关键在于两点：SoC的控制器的寄存器理解和Nand芯片本身的文档、流程图等信息。
		2、 对于我们来说，学习NandFlash，要注意的是：
			第一，结合SoC的数据手册、Nand芯片的数据手册、示例代码三者来理解。
			第二，出血时不要尝试完全不参考自己写出Nand操作的代码，初学时应该是吸纳理解实例diamante，知道这些代码是怎么写出来的，必要时对照文档来理解代码。代码理解之后去做实践，实践成功以后在考虑自己不参考代码只参考文档来写处Nand操作的代码。
			
1.11.6 iNand介绍
	1）iNand/eMMC/SDCard/MMCCard的关联
		1、 最早出现的是MMC卡，卡片式结构，按照MMC协议涉及。（相较于NandFlash芯片来说，MMC卡由2个优势：第一是卡片化，便于拆装；第二是协议接口，兼容性好。）
		2、 后来出现SD卡，兼容MMC协议。SD卡较MMC卡有一些改进，譬如写保护、速率、容量等。
		3、 SD卡遵守SD协议，有多个版本。多个版本之间向前兼容。
		4、 iNand/eMMC在SD卡的基础上发展起来的，较SD卡的区别就是将SD卡芯片化了（解决卡的接触不良问题，便于设备迷你化）。
		5、 iNand和eMMC的关联：eMMC是协议，iNand是Sandisk公司符合eMMC协议的一种芯片系列名称。

	2）iNand/eMMC的结构框图及其与NandFlash的区别
		1、 iNand内部也是有存储系统和接口电路构成（和Nand结构特性类似，不同之处在于接口电路功能不同）。
		2、 iNand的接口电路复杂，功能很健全。譬如：
			一、 提供eMMC接口协议，和SoC的eMMC接口控制器通信对接。
			二、 提供块的ECC校验相关裸机，也就是说iNand本身自己完成存储系统的ECC功能，SoC使用iNand时自己不用写代码来进行ECC相关操作，大大简化了SoC的编程难度。（NandFlash分2中：SLC和MLC，SLC更稳定，然容量小价格高；MLC容易出错，但是容量大价格低）。
			三、 iNand芯片内部使用MLC Nand颗粒，所以性价比很高。
			四、 iNand接口电路还提供了cache机制，所以iNand的操作速度很快。

	3）iNand/eMMC的物理接口和SD卡物理接口的对比
		1、 210芯片支持4通道的SD/MMC，在210中实际是在SD/MMC0通道接了iNand芯片，而SD/MMC2接了SD卡（SD/MMC3也接了SD卡）
		2、 对比iNand和SD卡接线，发现：这两个接线几乎是一样的，唯一的区别就是SD卡IO线有4根，而iNand的IO有8根。
		3、 所以实际操作iNand芯片时和操作SD卡时几乎一样的（物理接线几乎一样，软件操作协议几乎一样）。

	4）结论：iNand/eMMC其实就是芯片化的SD/MMC卡，软件操作和SD卡相同
		1、 分析iNand芯片的操作代码时，其实就是以前的SD卡的操作代码。一些细节的区别就是为了区分各种不同版本的SD卡、iNand的细节差异。

1.11.7 SD卡-iNand卡的操作
	1）硬件接口：DATA、CLK、CMD
		1、 iNand的IO线有8根，支持1、4、8线并行传输；SD卡IO线有4根，支持1、4线并行传输。
		2、 CMD线用来传输命令、CLK线用来传输时钟信号。
		3、 接口有CLK线，工作时主机SoC通过CLK线传输时钟信号给SD卡/iNand芯片，说明：SD/iNand是同步的，SD/iNand的工作速率是由主机给它的CLK频率决定的。

	2）命令响应的操作模式
		1、 SD协议事先定义了很多标准的命令（CMD0、CMD1...），每个命令都有它的作用和使用条件和对应的响应。SD卡工作的时候就是一个一个的命令周期组合起来的，在一个命令周期中，主机先发送CMD给SD卡，然后SD卡解析并执行这个命令，然后SD卡根据结果会发给主机SoC一个响应。（有些命令时不需要响应的，这是SD卡不会给主机回发响应，主机也不用等待响应）。标准的命令 + 响应的周期中，主机发完一个命令后应该等待SD卡的响应而不是接着发吓一跳命令。

	3）SD/iNand的体系结构图
		1、 SD卡有一个接口控制器，这个控制器类似于单片机，这个单片机的程序功能及时通过CMD线接收外部主机SoC发给SD卡的命令码，然后执行这个命令并且回发响应给主机SoC。这个单片机处理命令及回发响应遵循的就是SD协议。这个单片机同时可以控制SD卡内部的存储单元，可以读写存储单元。

	4）SD/iNand的寄存器（重点是RCA寄存器）
		1、 注意这里说的是SD卡内部的寄存器，而不是主机SoC的控制器的寄存器。（很多外置芯片内部都是有寄存器的，这些寄存器可以按照一定的规则访问，访问这些寄存器可以得知SD卡的一些内置信息。
		2、 RCA（relative address，相对地址寄存器）。我们在访问SD卡时，实际上SD卡内部每个存储单元的地址没有绝对数字，都是使用相对地址。相对地址由SD卡自己决定的，存放在RCA寄存器中。

	5）SoC的SD/MMC/iNand控制器简介
		1、 不同的SoC可能在SD/MMC/iNand等支持方面有差异，但是如果支持都是通过内部提供SD控制器来支持的。
		2、 210的SD卡控制器在section8.7部分。

1.11.8 SD-iNand代码实践分析1
	1）命令吗CMD和ACMD
		1、 SD卡工作在 命令 + 相应 的模式下的。
		2、 SD协议的命令分2中：CMDx 和 ACMDx。 CMD是但命令的命令，就是单独发一个CMD即可表示一个意思。ACMD是一种扩展，就是发2个CMD假期阿里表示一个意思。可以认为 ACMDx = CMDy + CMDz。（y一般是55）

	2）卡类型识别SD or MMC？
		1、 MMC协议、SD协议、eMMC协议本身是一脉相承的，所以就造成了一定的兼容性，所以当我们SoC控制器工作时连接到SoC上的可能是MMC卡、也可能是SD卡、也可能是iNand芯片。主机SoC需要去识别这个卡到底是什么版本的卡。
		2、 SoC如何区分卡中了？ 因为不同版本的卡内协议不同，所以对卡识别命令的响应也是不同的。SoC通过发动一些命令、听取响应就可以根据不同的响应判断卡的版本。

	3）卡状态
		1、 SD卡内部的控制器类似于一个单片机，这个单片机其实是一个状态机。所以SD卡任何时候都有一个状态（空闲、准备好、读写、出错...都是事先定义好的），在这种状态下能够接受的命令是一定的，接收到命令之后执行一定的操作然后根据操作结果会跳转为其他状态。如果主机发过来的命令和当前状态不符状态机就不响应，如果收到命令和当前状态相符就会执行相应操作，执行完之后会根据结果跳转为其他状态。

	4）卡回复类型
		1、 一般来说，SD卡的命令都属于： 命令 + 响应 模式的。也有极少数的SD卡命令时不需要回复的。
		2、 卡的回复有R1、R2...R8等8中类型，每种卡回复类型都有自己的解析规则。然后卡在特定状态下响应特定命令时有可能回复那种响应都是SD协议事先规定好的，详细细节要查阅协议文档。

1.11.8 SD-iNand代码实践分析2
	1）Linux内核风格的寄存器定义
		1、 定义一个基地址，在定义一个访问寄存器相对于基地址的偏移量。访问时使用 ： 基地址 + 偏移量。

	2）SD/iNand相关的GPIO初始化
		1、 GPIO相关的GPG0初始化
		2、 时钟初始化。
		3、 要求能在两三分钟内完全看懂这些代码涉及到的知识，要能够在数据手册、原理图中找到相对应的点，要能狗瞬间明白代码中涉及到的C语言语法技巧，这样才能融汇贯通，才能够从代码中学到东西。

	3）SD/iNand相关的时钟系统设置

	4）SD/iNand相关的时钟设置
		1、 SD卡本身工作需要时钟，但是自己有没有时钟发生单元，依靠主机SoC的控制器通过SD接口中的CLK线传一个时钟过来给SD卡内部使用。所以主机SD卡控制器先初始化号自己的时钟，然后将自己的时钟传给SD卡。
		2、 因为此时刚开始和SD卡通信，主机不清楚SD看属于哪个版本（高版本和低版本的SD卡读写速率不同，高版本的可以工作在低版本的速率下，低版本的SD卡不能工作在高版本速率下），所以先给SD卡发400KHz的低速率时钟，SD卡拿到这个时钟后就能工作了。然后在后面和SD卡进一步通信时去识别SD卡的版本号，识别后再根据SD卡的版本进一步给它合适的时钟。

1.12.1 什么是I2C通信
	1）物理接口：SCL + SDA 
		1、 SCL（serial clock）：时钟线，传输CLK信号，一般是I2C主设备向从设备提供时钟通道
		2、 SDA（serial dara）：数据线，通信数据都通过SDA线传输。

	2）通信特征：串行、同步、非差分、低速率
		1、 I2C属于串行通信，所有的数据以位为单位在SDA线上串行传输。
		2、 同步通信就是通信双方工作在同一个时钟下，一般是通信的A方通过一根CLK信号线传输A自己的时钟给B，B工作在A传输的时钟。所以同步通信的显著特征就是：通信线中有CLK
		3、 非差分。因为I2C的通信速率不高，而且通信双方距离很近，所以使用电平信号通信。
		4、 低速率。I2C一般使用在同一个板子上的2个I2C之间的通信，而且用来传输的数据量不大，所以本身通信速率很低（几百KHz，不同的I2C芯片的通信速率可能不同，具体在编程的时候要看自己所使用的的设备允许的I2C通信最高速率，不能超过这个速率）

	3）特出特征1：主设备 + 从设备
		1、 I2C通信的时候，通信双方地位是不对等的，而是分主设备和从设备。通信由主设备发起，有主设备主导，从设备只是按照I2C协议被动的接收主设备的通信，并及时响应。
		2、 谁是主设备谁是从设备是由通信双方来定的（I2C协议并无规定），一般来说一个芯片可以只能做主设备，也可以只能做从设备、也可以技能做主设备又能当从设备（软件配置）
		。
	4）突出特征2：可以多个设备挂载一条总线上（从设备地址）
		1、 I2C通信可以一对一（一主一从），也可以一对多（一主多从）。
		2、 主设备负责调度总线，决定某一时间和那个从设备通信。注意：同一时间内，I2C的总线只能传输一堆设备的通信信息，所以同一时间只能有一个从设备和主设备通信，其他从设备处于“休眠”状态，不能出来捣乱，否则通信就乱套了。
		3、 每一个I2C从设备在通信中都有一个I2C从设备地址，这个设备地址是从设备本身固有的属性，然后通信时主设备需要知道自己将来通信的那个从设备的地址，然后在通信中通过地址来甄别是不是自己要找的那个从设备。（这个地址是一个电路板上唯一的，不是全球唯一的）

	5）主要用途：SoC和周边外设之间通信（典型的如EEPROM、电容触摸IC、各种sensor等）

1.12.2 由I2C学通信时序
	1）什么是时序？
		1、 时序：字面意思，时序就是时间顺序，实际上在通信中时序就是通信线上按照时间顺序发生的电平变化，以及这些变化，以及这些变化对通信的意义就叫时序。

	2）I2C的总线空闲状态、起始位、结束位
		1、 I2C总线上有1个主设备，n（n>=1）个从设备。I2C总线上有2中状态：空闲态（所有从设备都未和主设备通信，此时总线空闲）和忙态（其中一个从设备在和主设备通信，此时总线被这一对占用，其他从设备必须歇着）。
		2、 整个通信分为一个周期一个周期的，两个相邻的通信周期是空闲态。每一个通信周期有一个起始位开始，一个结束位结束，中间是本周期的数据。
		3、 起始位并不是一个时间点，起始位是一个时间段，在这段时间内总线变化情况是：SCL线位置高电平，同时SDA线发生一个从高到低的下降沿。
		4、 停止位也是一个时间段，这在短时间内总线变化情况是：SCL线位置高电平，同时SDA线发生一个从低到稿的下降沿。

	3）I2C数据传输格式（数据位&ACK）
		1、 每一个通信周期的发起和结束都是有主设备来做的，从设备只有被动的响应主设备，没法自己自发的去做任何事。
		2、 主设备在每个通信周期会先发8位的从设备地址（其实8位中只有7位是从设备地址，还有1位表示主设备下面要写入还是读出）到总线（主设备是以广播的形式发送的，只要是总线上的所有从设备其实都能收到这个信息）。然后总线上的每个从设备都能收到这个地址，并且收到地址后和自己的设备地址比较看是否相等。如果相等说明主设备本次通信就是给我说话，如果不想等说明这次通信与我无关，不用听了不管了。
		3、 发送方发送一段数据后，接收方需要回应一个ACK。这个相应本身只有1个bit位，不能懈怠有效信息，只能表示2个意思（要么表示收到数据，即有效响应；要么表示未收到数据，无效响应）。
		4、 在某一个通信时刻，主设备和从设备只能有一个在发（占用总线，也就是想总线写），另一个在收（从总线读）。如果在某个时间主设备和从设备都试图向总线写那就完蛋了，通信就乱套了。

	4）数据在总线上的传输协议
		1、 I2C通信时的基本数据单位也是以字节为单位的，每次传输的有效数据都是1个字节（8位）。
		2、 起始位及其后的8个CLK中都是主设备在发送（主设备掌控总线），此时从设备只能读取总线，通过读总线来得知主设备发给从设备的信息；然后到了第9个周期，按照协议规定从设备需要发送ACK给主设备，所以此时主设备必须释放总线（主设备吧总线置高电平然后不要动，其实就类似与总线空闲状态），同时从设备试图拉低总线发出ACK。如果从设备拉低总线失败，或者从设备根本就没有拉低总线，则主设备看到的现象就是总线在第9周期仍然一直保持高，这对主设备来说，意味着我没收到ACK，主设备就认为刚才给从设备发送的8字节不对（接收失败）。


1.12.3 S5PV210的I2C控制器
	通信双方本质上是通过时序在工作的，但是时序会比较复杂不利于SoC软件完成，于是乎解决方案是SoC内部内置了硬件的控制器来产生通信时序。这样我们写软件时只需要想控制器的寄存器中写配置值即可，控制器会产生适当的时序在通信线上和对方通信。
	1）结构框图
		1、 时钟部分：来源PCLK_PSYS，经过内部分频得到I2C控制器的CLK，通信中这个CLK会通过SCL线传给从设备。
		2、 I2C总线控制逻辑（前台代表I2CON、I2CSTAT这两个寄存器），主要负责产生I2C通信时序。实际编程中要发送起始位、停止位、接收ACK等都是通过这两个寄存器（背后所代表的电路模块）实现的。
		3、 移位寄存器（shift register），将代码中要发送的字节数据，通过移位寄存器变成1个位一个位的丢给SDA线上发送/接收。
		4、 地址寄存器 + 比较器：本I2C控制器做从设备的时候用。

	2）系统分析I2C的时钟
		1、 I2C时钟来源PCLK（PCLK_PSYS，66MHz），经过2级分频后得到的。
		2、 第一季分频是I2CCON的bit6,0：PCLK/16，1：PCLK/512
		3、 第二季分频是得到最终I2C控制器工作的时钟，以I2CCLK这个中间时钟为来源，分频系数【1，16】。
		4、 最终得要得到时钟是2级分频后的时钟，譬如一个可用的设置是：65000KHz/512/4=31KHz。

	3）主要寄存器I2CCON、I2CSTAT、I2CADD、I2CDS
		1、 I2CCON + I2CSTAT：只要同来产生通信时序和I2C接口配置。
		2、 I2CADD：用来写自己的slave address
		3、 发送/接收的数据都放在这里

1.12.4 X210板载gsensor介绍
	1）原理图查阅
		1、 gsensor的供电有PWMTOUT3引脚控制，PWMTOUT 低 gsensor不工作，PWMTOUT 高 gsensor工作。
		2、 gsensor的SDA和SCL接的是S5PV210的I2C端口0
		3、 将来编程时在gsensor_init函数中要去初始化相关GPIO。要把相应的GPIO设置为正确的模式和输入输出值。

	2）重力加速度传感器介绍
		1、 用在手机、平板、智能手表等设备上，用来感受人的手的移动，获取一些运动的方向信息用来给系统作为输入参量。
		2、 可以用来设计只能手表的记不起功能。
		3、 重力传感器、地磁传感器、陀螺仪等三个传感器结合起来，都是用来感知运动的速度、方位等信息的，所以现在最新的有9轴传感器，就是把三者结合起来，并且用一定的算法进行综合得出结论，目的是更加准确。
		4、 一般的传感器的接口有2中：模拟接口和数字接口。模拟接口：用接口电平变化来作为输出的（譬如模拟接口的压力传感器，在压力不同时输出电平在0~3.3V范围内变化，每一个电压对应一个压力。），SoC需要用AD接口来对接这种传感器对它输出的数据进行AD转换，转换得到数字电压，在用数字电压去校准得到压力值；数字接口是后来发展出来的，数字接口的sensor是在模拟接口的sensor基础上，内部集成了AD，直接（通过一定的总线接口协议，一般是i2c）输出一个数字值的参数，这样SoC直接通过总线接口初始化、读取传感器输出的参数即可（譬如gsensor、电容触摸屏IC）。

	3）I2C从设备的设备地址
		1、 KXTE9的I2C地址固定为0b0001111（0x0f）
		2、 I2C从设备地址本身是7位的，但是在I2C通信中发送I2C从设备地址时实际发送的事8位，这8位中高7位（bit7~bit1）对应I2C从设备的7位地址，最后一位（LSB）存放的事R/W信息（就是说下一个数据是主设备写从设备读:0，还是主设备读从设备写：1）
		3、 对于KXTE9来说，主设备（SoC）发送gsensor信息时，SDA应该是：0b00011110，如果是主设备读取gsensor信息时，SDA应该是：0b00011111

	4）I2C从设备的通信速率
		1、 I2C协议本身属于低速协议，通信速率不能太高。
		2、 实际上通信的主设备和从设备本身都有最高的通信速率限制（属于各个芯片本身的参数），实际编程时的速率必须小于两个设备的速率即可。

1.12.5 I2C总线的通信流程
	1）S5PV210的主发送流程图

	2）S5PV210的主接收流程图

	3）gsensor的写寄存器路程图

	4）gsensor的读寄存器流程图


1.12.5 I2C通信代码分析1
	1）I2C控制器初始化：s3c24xx_i2c_init
		1、 初始化：初始化GPIO、设置IRQEN和ACKEN、初始化时钟

	2）I2C控制器主模式开始一次读写：s3c24xx_message_start

	3）I2C控制器主模式结束一次读写：s3c24xx_i2c_stop

1.12.5 I2C通信代码分析2
框架分析：
	通过读写gsensor芯片内部的寄存器得到一些信息，为了完成这个目的，需要可以读写gsensor的寄存器，根据gsensor的规定我们需要按照一定的操作流程来读写gsensor的内部寄存器，这是一个层次（传输层、协议层、应用层）；我们要按照操作流程去读写寄存器，就需要考虑I2C接口协议（这就是所谓的物理层）。此时主机SoC有或没有控制器，有控制器时考虑控制器的寄存器，没控制器时要自己软件模拟时序。

	协议层的代码主要去结余gsensor芯片；物理层代码主要取决于主机SoC。
	1）gsensor写寄存器：gsensor_i2c_write_reg

	2）gsensor读寄存器：gsensor_i2c_read_reg

	3）gsensor编程：gsensor_inittial等

1.13.1 ADC的引入
	1）什么是ADC
		1、 ADC：analog digital converter，AD转换，模数转换（也就是模拟转数字）
		2、 CPU本身是数字的，而外部世界变量（如电压、温度、高度、压力...）都是模拟的，所以需要用CPU来处理这些外部的模拟变量的时候就需要做AD转换。

	2）为什么需要ADC
		1、 为了用数字技术来处理外部模拟量。

	3）关于模拟量和数字量
		1、 模拟的就是连续的，现实生活中的时间、电压、高度都是模拟的（连续分布的，划分的话可以无心啊的更小划分）。模拟量反应在数学里面就是无限小时位（从0-1之间有无数个数）
		2、 数字的就是离散的，离散的就是不连续的。这种离散处理实际上是从数学上对现实中的模拟量的一种悠闲精度的描述。数字化就是离散化，就是把连续分布的模拟量按照一定精度进行取点（采样）编程有限多个不连续分布的数字值，就叫数字量。
		3、 数字化的意义就在于可以用（离散）数字来简化描述模拟量，这东西是计算机技术的基础。
		4、 计算机处理参量的时候都是数字化的，计算机需要数字化的值来参与运算。如果系统输入参数

	4）AD1与DA
		1、 AD：analog to digital，DA：digital to analog，数字转模拟。
		2、 纯粹用CPU是不可能是实现数字转模拟，因为cpu本身就是数字的。使用一些物理器件就可以实现数字转模拟。
		3、 数字转模拟的作用。

1.13.2 ADC的主要相关概念
	1）量程（模拟量输入范围）

	2）精度（分辨率）

	3）转换速率（MSPS与convertoy clock的不同）
		1、 AD芯片进行AD转换是要好费时间的，不同的芯片是不一样的，同一颗芯片在配置（精读配置、时钟频率等）不一样时转换时间也不一样的。
		2、 详细需要时间可以参考数据手册。一般数据手册中描述转换速率的单位是MSPS（第一个M是兆，S是sample，就是采样；PS就是persecond，总的意思就是兆样本每秒，每秒转出来多少M个数字值）
		3、 AD工作都需要一个时钟，这个时钟有一个范围，我们实际给他配置时不要超出这个范围就可以了。AD转换时在这个时钟下进行的，时钟的频率控制着AD转换的速率。注意：时钟频率和MSPS不是一回事，只是成正比不是完全相等。譬如S5PV210中的AD转换器，MSPS = 时钟频率/5。

1.13.3 S5PV210的ADC控制器
	1）ADC和（电阻式）触摸屏的关系
		1、 ADC在section10
		2、 电阻式触摸屏本身工作时依赖AD转换，所以在210的SoC中电阻式触摸屏接口本身和ADC接口是合二为一的。或者说电阻触摸屏接口使用了（复用了）ADC的接口。

	2）ADC的工作时钟框图
		1、 ADCCLK是ADC控制器的工作时钟，也就是1.13.2.3节中讲到的conventor clock。从时钟框图可以看出，他是PCLK（PCLK_PSYS）经过一次分配后得到的。所以将来初始化ADC控制器时一定有一个步骤是初始化这里的分频器。

	3）210的10个ADC通道（注意ADC引脚和GPIO的区别）
		1、 210支持10个通道，分别叫 AIN[0]~AIN[9]，即：可以同时进行10路AD转换。
		2、 SoC的引脚至少分2中：digit数字引脚和analog模拟引脚。我们以前接触的GPIO都属于数字引脚，ADC chanel通道引脚属于模拟引脚。数字引脚和模拟引脚一般是不能混用的。

	4）ADC控制器的主要寄存器
		1、 TSADCCON0		
		2、 TSCON0
		3、 TSDATX0		转出来的AD值存在这里，我们读也是读这里。
		4、 CLRINTADC0	清中断
		5、 ADCMUX		选择AIN[]通道

		等待触摸屏转换完成的方法有2种：一种是检查标志位，第二种是中断。第一种方式我们先开启转换然后循环不停的检查标志位知道标志位为1；第二种是设置好中断，写好中断isr来读取AD转换数据。然后开启中断后CPU就不用管了，等AD转换完成后生成一个中断信号给CPU，就会进入中断处理流程。第一种方式是同步的，第二种是异步的。
		AD转换都是需要反复进行的，转弯一次要立即开启下一次住哪换，所以需要一种机制能够在一次转完自动开启下一次。这个机制就叫start by read，这个机制的工作方法是：当我们读取本次AD转换的AD值后，硬件自动开启下一次AD转换。

1.13.4 ADC转换的编程实践1
	1、 AD控制器初始化
		1、 
	2、 循环进行AD采样

1.13.4 ADC转换的编程实践2
	1、 编译运行调试

	2、 start by read模式介绍
		1、 应用方法：开启 start by read模式，第一次先读一次丢掉，这次读就能开启下一次AD转换，然后以后就可以不停的读取AD值了。
	3、 DAC的应用简介

1.14.1 LCD简介
	1）什么事LCD
		1、 LCD（Liquid Crystal Display）俗称液晶。

	2）其他主流的显示设备（LED、CRT、等离子、OLED）
		1、 CRT：阴极摄像管显示器
		2、 等离子显示：为成为主流。
		3、 OLED：主流，取代LCD
		4、 LED：主要用在户外大屏幕
		5、 LCD：低端过期主流

	3）LCD的显示原理和特点（液晶分子透光 + 背光）
		1、 背光：白光
		2、 液晶分子有 红蓝绿 组成

	4）LCD的发展史和种类
		1、 TN面板最早，响应性不够好，有拖尾现象。
		2、 STN面板。有效解决了拖尾现象。
		3、 FTF的最大特点是超薄。
		4、 TFT技术至上发展出来很多更新的技术。

1.14.2 LCD的接口技术
	1）从电平角度来讲本质上都是TTL信号
		1、 什么事TTL信号？ +5v 表示逻辑1， 0v 表示逻辑0，这就叫TTL电平，和CMOS电平想对比。
		2、 SoC的LCD控制器硬件借口是TTL电平的，LCD这边硬件接口也是TTL电平的。所以他们两本来是可以直接对接的，手机、平板、开发板都是这样直接对接的（一般用软排线链接）。
		3、 TTL电平的缺陷是不能传递太远，如果LCD屏幕和主板屏幕控制器太远（1米甚至更远）就不能直接TTL连接了，要进行转换。转换方式：主机SoC(TTL) -> VGA -> LCD屏幕（TTL）

	2）各种借口（TTL、LVDS、EDP、MIPI...）在传输速率、距离、适配性方面不同（参考资料：http://blog.csdn.net/wocao1226/article/details/23870149）

	3、 RGB借口详解（参考数据手册P1207页时序图）
		1、 VD[23:0]：24根数据线，用来传输图像信息。课件LCD是并行接口，速率才够快。
		2、 HSYNC（水平同步信号）
		3、 VSYNC（垂直同步信号）：时序信号线，为了让LCD能够正常显示给的控制信号。
		4、 VCLK（像素时钟）： LCD工作室需要主板控制器给LCD模组一个工作时钟。VCLK。
		5、 VDEN（数据有效标志）： 时序信号，和 HSYNC 、 VSYNC结合使用。
		6、 LEND（行结束标志，不是必须的）： 时序信号，非必须的，譬如X210接口就没有。

1.14.3 LCD如何显示图像1
	1）像素（pixel）
		1、 像素就是组成图像的最基本的元素，或者说显示中可以被控制的最小单位，整个图像就是由很多歌像素组成的。
		2、 像素可以被单独控制，或控制其亮或不亮（单色屏）、或控制器亮度强弱（譬如亮50%，35%，这样叫灰度屏，以前的黑白电视机）、或控制其显示一定的颜色（现在最常用的彩色显示屏）。
		总结：像素很重要，整个显示图像是由一个个的像素组成的。我们要在显示器上显示一个图像，就是把这个图像离散化成一个一个的点，然后把各个店的颜色对应在显示器的像素上。

	2）扫描
		1、 扫描是一个动作而不是一个名字。扫描就是依次讲颜色数值放入屏幕中所有的像素的这个过程。
		2、 扫描这个词是由最早的CRT显示器遗留下来的，到LCD显示器的年代本来已经失去意义了，但是我们还是延续着这么叫。
		3、 显示器的扫描显示原理依赖于人眼的视觉暂留。只要显示器扫描频率大于人眼的发现频率，人眼看到的图像就是恒定的。如果扫描频率偏小人眼就会看到闪动。（扫描频率的概念就叫做刷新率）。
		
	3）驱动器&控制器
		1、 LCD驱动器一般和LCD显示面板集成在一起（一般面板于驱动器是不同供应商，集成厂商买来面板和驱动器后集成在一起做成LCD屏幕），面板只负责里面的液晶分子旋转透光，面板需要一定的模拟电信号来控制液晶分子；LCD驱动器芯片负责给面板提供液晶分子的模拟电信号，驱动器的控制信号（数字信号）来自于自己的数字接口，这个接口就是LCD屏幕的外部接口（第二节中讲到的接口）。
		2、 LCD控制器一般集成在SoC内部，它负责通过数字接口想远端的LCD驱动器提供控制像素的数字信号。LCD控制器的关键在于时序，他必须按照一定的时序和LCD驱动器通信；LCD控制器受SoC控制，SoC会从内存中拿像素数据给LCD控制器并最终传给LCD驱动器。

	4）显示内存（显存）
		1、 SoC在内存中挑选一段内存（一般来说是程序员随便挑选的，但是挑选的时候必须符合一定的规矩），然后通过配置将LCD控制器和这一段内存（以后称为显存）链接起来构成一个映射关系。一旦这个关系建立之后，LCD控制器就会自动从显存中读取像素数据传输给LCD驱动器。这个显示的过程不需要CPU的参与。
		2、 显示体系建立起来之后，CPU就不用再管LCD控制器、驱动器、面板这些东西了；以后CPU就只关心显存了，因为我们只要把要显示的图像的像素数据丢到显存中，硬件就会自动响应（屏幕上就能自动看到显示的图像了）。

		总结：LCD显示是分为2个阶段：第一个阶段就是建立显示体系的过程，目的就是CPU初始化LCD控制器使其和显存联系起来构成映射；第二个阶段就是映射建立之后，此阶段主要任务就是将显示的图像丢到显存中去。

1.14.4 LCD的六个主要时序参数
	1）LCD显示单位：帧（frame）
		1、 显示器上一整个画面的内容称为一帧（frame），整个显示器工作时是一帧一帧的在显示。
		2、 电影实际就是以每秒钟24帧的速度在播放图片。
		3、 帧内数据：一帧分为多行，一行分为多像素，因此一帧图像其实就是多个像素组成的矩阵。
		4、 帧外数据：整个视频由很多帧构成，最终播放视频时逐个播放各个图像帧即可。

	2）LCD显示一帧图像的过程
		1、 首先把帧分为行，然后再把行分为像素，然后逐个像素去显示。（显示像素：其实就是LCD驱动器按照接收到的LCD控制器给的显示数据，驱动一个像素的液晶分子旋转，让像素显示出相应的颜色值得过程）

		2、 关键点：LCD控制器和驱动器之间一次只能传一个像素点的显示数据。所以一帧图像在屏幕上其实是串行的依次被像是上去的，不是同一时间显示出来的。

	3）为了向前兼容出现的六个时序参数
		HSPW 水平信号脉冲宽度
		HBPD 水平同步信号前肩
		HFPD 水平同步信号后肩

		VSPW 垂直信号脉冲宽度
		VBPD 垂直同步信号前肩
		VFPD 垂直同步信号后肩

	1、 一行的通信过程是这样的：先发送一个HSYNC高电平脉冲（脉冲宽度是HSPW），脉冲告诉驱动器下面的信息是一行信息。然后开始这一行信息，这一行信息包括3部分： HBPD + 有效信息 + HFPD。其中前肩、后肩都属于时序信息（和LCD屏幕具体有关），有效行信息就是横向分辨率。所以你可以认为一行总共包含4部分： HSPW + HBPD + 有效信息 + HFPD。
	2、 一帧图像其实就是一列，一列图像由多个行组成，每行都是上面讲的这个时序。
	3、 一帧图像的通信过程是这样的：整个帧图像信号分为4部分：VSPW + VBPD + 帧有效信息 + VFPD。VSPW是帧同步信号的宽度，用来告诉驱动器一帧图像要开始了；VBPD、VFPD分别是帧信息的前后肩
	4、 这六个参数对于LCD显示器不是必须的，这些信号其实是老式的CRT显示器才需要的。LCD本身不需要，但是出于历史兼容性的要求，LCD选择了兼容CRT显示器的这些时序要求，所以理解LCD显示器时序和编程时，用CRT的方式来理解不会或。
	5、 注意：这几个时序参数本身是LCD屏幕本身的参数，与LCD控制器无关。所以同一个主板如果接的屏幕不一样则时序参数设置也会不同。这些参数来源是：第一，厂家会直接给出，一般以实例代码的形式给出。第二种，来自于LCD的数据手册。
		.h_fp	= 210,
		.h_bp	= 38,
		.h_sw	= 10,
		.v_fp	= 22,
		.v_fpe	= 1,
		.v_bp	= 18,
		.v_bpe	= 1,
		.v_sw	= 7,

	第二种方式查数据手册。

	补充：
		1、 注意这些数字的单位。H开头的三个单位都是DCLK（像素时钟）。V开头的三个单位是TH。好处是我们改变了江苏时钟的设置时，不用改变这里的时序参数。
		2、 这些时序参数如果没设置好会影响什么？ 屏幕会跑偏。

1.14.7 LCD显示的主要相关概念
	1）像素（pixel）
		1、 整个图像是由一个个的像素组成的，像素就是一个显示点。

	2）像素间距（pitch）
		1、 pitch是连续2个像素的限速中心的距离。一般的像素是方形的，所以横向pitch和纵向的pitch一样的。但是也有不一样的。
		2、 相适应间距影响屏幕的最佳观看距离。像素间距大的适合远距离看，像素间距的适合近距离看。

	3）分辨率（resolution）
		1、 整个屏幕的横向和纵向的像素个数就叫分辨率，譬如X210开发板用的屏幕是 800 * 480 。
		2、 屏幕尺寸和分辨率无关的，开发板的屏幕尺寸是7寸的（对角线位7英寸）
		3、 屏幕尺寸和分辨率和像素间距三者之间有关联。

	4）清晰度
		1、 清晰度是一个主观概念，是人眼对显示效果的一个主观判断。
		2、 客观来讲，清晰度由分辨率、像素间距决定。一般来说分辨率高且屏幕越小越清晰。

	5）像素深度（bits per pixel，简称bpp）
		1、 一个像素在计算机中由多少个字节数据来描述。
		2、 计算机中用二进制位来表示一个像素的数据，用来表示一个像素的数据越多，则这个像素的颜色值更加丰富、分的更细，颜色深度就更深。
		3、 一般来说像素深度有这么几种：1位、8位、16位、24位、32位。

1.14.8 颜色在计算机中的表示
	1）颜色的本质
		1、 颜色是主观存在的，颜色其实是自然光在人的眼睛肿和大脑中产生的一种映像。
		2、 颜色的本质决定于光的波长，

	2）自然光的颜色是连续的
		1、 光的波长是连续的，导致颜色也是连续的。理论上，只要你的眼睛分辨能力足够好，可以在自然界中发现无数种颜色。

	3）计算机中的颜色是离散的
		1、 计算机中不可能存储无数种颜色，所以必须将颜色有限化，所以就用有限中颜色来代表自然界总的无限种颜色。这个理论类似于AD转换。
		2、 离散化表达颜色的缺点是不够真实，漏掉了很多种颜色。因此计算机中所能表达的颜色没有自热界中丰富（计算机屏幕上显示图像和真实图像有差别）。
		3、 计算机所能表达的颜色种类个数，这个参数叫：像素深度bpp。

	4）常见的像素深度：1位、8位、16位、24位、32位
		1、 1位：一个二进制位表示颜色，单色显示。示例：理发店门口的LED屏。
		2、 8位：用8个二进制位来表示颜色，此时可以表示256中颜色。这种叫灰度显示。黑白。中间的数字对应不同的灰。
		3、 16位：此时能表示 65536中颜色，彩色显示，一般是 RGB565的颜色分布。可模拟自然界大部分的颜色。
		4、 24位：此时可以表示 16777216。这种表示方法和16位色原理是一样的RGB各8位，只是精度更高。RGB888->真彩色，RGB565->假彩色。
		5、 32位：总共用32位二进制表示颜色，其中24色表示红绿蓝三原色（还有RGB888），剩下8位表示透明度。这种显示就叫做ARGB（A是阿尔法，表示透明度），现在PC机种一般都用ARGB颜色。
		
		补充：三基色，红绿蓝

1.14.9 S5PV210的LCD控制器
	1）FIMD接口框图
		1、 210的LCD控制器叫FIMD，FIMD是210内部和图像处理相关的一些部件，在摄像头等和图像处理有关的部分都可以有关联。
		2、 FIMD在内部与AHB总线等相连接，在外部提供RGB接口、I80接口、YUV接口与外部相连接，我们实际使用的是RGB接口。

	2）虚拟屏幕叠加（数据手册P1194）
		1、 虚拟屏幕的意思是，我们平时看到的屏幕上显示出来的场景实际是很多个屏幕显示叠加在一起的效果（譬如新图像、电视台台标、下方飘动的字幕新闻）
		2、 像S5PV210的LCD控制器中有5个虚拟屏幕window0-window4，虚拟屏幕不存在与真实而存在于内存中。（之前讲过，LCD显示时实际是显示的是对应的内存中的显存区域的数值）虚拟屏幕其实就是一个内存中的显存区域，有几个显存区域就有几个虚拟屏幕，但是这些虚拟屏幕都被映射到一个真实的显示屏上面，所以将来真实的显示效果实际是这几个虚拟屏幕的显示内容的叠加。（叠加时要注意上面一层会覆盖下面一层，所以要注意谁在前谁在后，设置寄存器时有这个选项）
		3、 使用虚拟屏幕而不是整个LCD使用一个显存是有一定好处的：第一，可以保证不污染源图像，方便处理；第二个，可以减少屏幕刷新，提高效率减少CPU的工作量。

	3）虚拟显示（数据手册P1206）
		1、 如何实现在小分辨率的屏幕上真实显示大分辨率的图像？
		2、 细节上，我们需要屏幕上看到不同图像时，需要显存区域进行刷新。即使只需要屏幕显示移动一点点，整个屏幕对应的显存空间也需要整个重新刷新，工作和完全刷新一幅图像一样。这样显示不好，这样CPU刷新屏幕的工作量太大了，效率很低。
		3、 如何能够在显示一个大图片的不同区域时让CPU刷新屏幕工作量减少？		方法就是虚拟显示：在内存中建立显存的时候实际建立一个很大的区域，然后让LCD去对应其中一部分区域作为有效区域。将来要显示大图像，直接将大图像全部一次性加载入现实缓存区，然后通过移动有效显示区域就可以显示大图像的不同区域了。

	4）主要寄存器简介

1.14.10 LCD编程实战 1-LCD控制器初始化
	1）要想LCD工作，必须给LCD屏幕和显存之间建立一个映射（映射实在CPU初始化LCD控制器来完成的）。本部分就是在完成这个过程（这也是LCD显示的2个阶段的第一阶段，第二阶段中我们只需要给显存中丢入响应的数据，LCD屏幕就会自动显示响应内容）。



1.14.10 LCD编程实战 2-LCD控制器初始化


1.15.1 输入雷设备简介
	1）input/output
		1、 IO输入输出，是计算机系统中的一个概念。计算机的主要功能是从外部获取数据然后进行计算加工得到输出数据病输出给外部（计算机可以看成数据处理器）。计算机和外部交互就是通过IO。每一台计算机都有个标准输入和标准输出。

	2）常见的输入类设备
		1、 键盘、鼠标、触摸屏、游戏摇杆、传感器、摄像头（摄像头并不是一个典型的输入类设备）。

	3）触摸屏的特点
		1、 触摸屏和人的关系很紧密，尤其是电容式触摸屏。
		2、 触摸屏和显示器关系很紧密。
		3、 电视应用：手机、平板电脑、收银机、工业领域。

	4）触摸屏的分类
		1、 常见的触摸屏分2种：电阻式触摸屏和电容式触摸屏。早起用电阻式触摸屏，后来发明了电容式触摸屏。
		2、 这两种特性不同、接口不同、编程方法不同、原理不同。

	5）触摸屏和显示屏的联系与区别
		1、 首先要高清楚：触摸屏是触摸屏，用来响应人的触摸事件的；显示屏是显示屏，用来显示。现在用的显示屏一般都是LCD。
		2、 为什么很多人会搞混这两个概念，主要是因为一般产品上触摸屏和显示屏是坐在一起的。一般外层是触摸屏，触摸屏是透明的，很薄；地下室显示屏用来显示图像，平时看到的图像时显示屏显示并且透过触摸屏让人看到的。

1.15.2 电阻式触摸屏的原理
	1）薄膜+玻璃（需要尖锐硬物点击）
		1、 要点是：薄、透明。前面板硬度稍弱，可以被硬物按下弯曲，后面板硬度很高，不会弯曲。
		2、 前面板和后面板在平时没有挨着，在外力按下之下，前面板（局部）形变，在这一点上前后面板会挨着。

	2）ITO（导电+透明+均匀压降）
		1、 ITO是一种材料，其实是一种涂料，特点是透明、导电、均匀涂抹。
		2、 呢么来玻璃和塑料都是不导电的，但是图上上ITO之后就变成到点了（同时还保持这原来透明的特性）。
		3、 ITO不但导电而且还有电阻，所有中间均匀涂了ITO之后再x1和y1之间接了一个电阻，再x2和y2之间也接了一个电阻。因为ITO形成的等效电阻在整个板上均匀分布的，所在在板子上某一点的电压和这一点的位置值成正比。
		4、 触摸屏经过操作，按下之后要的就是按下的坐标，坐标其实就是位置信息，这个位置信息和电压成正比了，而这一点的电压可以通过AD转换得到。这就是整个电阻式触摸屏的工作原理。

	3）X/Y轴分时AD转换
		1、 下面研究如何得到按下的这点的电压。
		2、 在第一个面板的一对电极上加电压，然后在另一个面板的一个电极和第一个面板的地之间去测量。在没有按下时测试无结果，但是在有人按下时在按下的哪一点2个面板接触，接触会导致第二个面板上整体的电压值和接触处的电压值相等，所以此时测量到的电压就是接触处在第一个面板上的电压值。
		2、 以上过程在一个防线进行一次即可测得该方向的坐标值，进行之后撤掉电压后再另一个方向的电极上加电压，故技重施，即可得到另一个方向的坐标。至此触摸事件结束。


	4）电压值对应坐标值（校准）
		1、 电压值和坐标值成正比，所以需要去校准它。校准就是去计算（0,0）坐标点的电压值是多少。

	5）思考：为什么电阻式触摸屏不支持多点触摸
		1、 多点同时按下无法争取测得电压值。多点触摸会导致短路。

1.15.3 S5PV210的电阻触摸屏控制器
	1）ADC与触摸屏控制器结构框图
		1、 S5PV210一共支持10路模拟输入，分别为AIN0-AIN9，其中AIN0-AIN1是制作模拟输入的，AIN2-AIN9分别可以支持2个电阻式触摸屏。所以4个模拟输入引脚负责一个电阻式触摸屏。
		2、 AD转换和触摸屏控制部分由2个附属单元。其中一个是反向控制器AINn引脚的逻辑，主要作用是在触摸屏获取坐标的过程中分时给xy方向供电和测量；第二个是中断产生部件，如果AD转换完成（主要针对AIN0和AIN1这两路）或者触摸屏被按下/叹气时，中断部件会产生一个中断通知CPU来处理书剑，这样就不用轮训检测触摸事件。

	2）Normal Operation Mode & Separate X/Y Position Convertion Mode
		1、 AD转换器有两种工作模式：正常操作模式和分时X/Y位置转换模式。
		2、 正常操作模式用作普通的AD转换，分时X/Y位置转换模式用作电阻式触摸屏。正常AD转换下降AD转换值放在TSDATX中，在分时X/Y模式下回降X/Y坐标分别放在TSDATX和TSDATY中。
		3、 对于AIN0-AIN1来说没有这么多模式，他们只工作在普通模式；对于AIN2-AIN9来说，因为被复用，所以才有2几种模式。如果我们将这几个引脚用作普通AD转换则配置为普通模式，如果用作电阻式触摸屏检测，则配置成分时X/Y模式。 

	3）中断参与
		1、 其实普通AD转换和触摸屏AD转换本身都可以不在中断参与下完成。
		2、 普通AD转换如果不要中断，那就去查询。开启一次转换后然后不断查询标志位，知道AD转换完硬件自动置位标志位后我们采取读取转换至就不会错。当然也可以用中断，控制器提供了一个相应的中断给普通AD转化。
		3、 触摸屏也可以用回这不用中断。对于SoC来说永远不知道人会什么时候按下或者弹起触摸屏，所以触摸屏的按下/弹起对SoC来说是纯粹的异步时间。对于这种情况SoC只有2中解决方案；轮训和中断。
	4）主要寄存器

1.15.4 电容式触摸屏的原理
	1）人体电流感应
		1、 利用人体电流感应现象，在手指和屏幕之间形成一个电容，手指触摸时吸走一个微笑电流，这个电流会导致触摸板上4个电极发生电流流动，控制器通过计算这4个电流比例就能算出触摸点的坐标（这个计算中设计AD转换）。

	2）专用电路计算坐标
		1、 电阻式触摸屏本身是一个完全被动期间，里面没有任何IC和电路，他的工作逻辑完全在SoC控制器器上；但是电容式触摸屏不同，电容式触摸屏需要自带一个IC进行坐标计算。因此电容式触摸屏工作时不需要主机SoC靠志气参与。
		2、 为什么这样设计？ 主要原因是电容式触摸屏的坐标计算太复杂，普通程序员无法写出合适的diamante解决这个问题，因此在电容式触摸屏中除了触摸板之外还附加了一个IC进行专门的坐标计算和统计。这个IC全权负责操控触摸板得到触摸操作信息，然后在通过数字接口和主机SoC进行通信。

	3）多个区块支持多点触摸
		1、 电阻式触摸屏不支持多点触摸，这是它本身的原理所限制，无法改变无法提升。
		2、 电容式触摸屏可以支持多点触摸（也可以单点触摸）。按照之前讲的电容式触摸屏的原理，单个电容式触摸屏面板也无法支持多点触摸，但是可以将一个大的触摸板分成多个晓得区块，每个区块相当于一个独立的小的电容式触摸屏面板。
		3、 多个区块多点触摸让电容触摸屏的坐标计算变复杂了，但是这个这个复杂性被电容触摸IC吸收了，还是通过数字接口和主机SoC报告触摸信息（触摸点数、每个触摸点的坐标等）。


	4）对外提供I2C的访问几口
		1、 电容触摸屏包含2部分：触摸板和电容触摸IC。触摸板就是一个物理器件，电容触摸IC一般做到触摸屏的软排线（FPC）上面。电容触摸IC负责操控触摸板、通过AD转换和分析得到触摸点个数、触摸坐标信息，然后以特定的数字接口与SoC通信。这个数字接口就是I2C。
		2、 对于我们主机SoC来说，电容式触摸屏其实就是一个I2C从设备。主机只需要通过I2C总线对这个从设备进行访问即可（从设备有自己特定的从设备地址）。从设备来讲，其实电容式触摸屏和其他传感器（gsensor等）并没有任何区别。


1.15.5 ft5x06电容触摸IC简介
	1）电阻式触摸屏和电容式触摸屏的特点对比
		1、 耐久性：		电容式触摸屏不容易坏，电阻式触摸屏容易坏
		2、 抗干扰性：	电容式触摸屏抗干扰性差，电阻式触摸屏好一些。
		3、 精准度：		电阻式触摸屏好一些，电容式触摸屏差一些。
		4、 用户体验：	电容式触摸屏好一些，电阻式触摸屏差一些。
		5、 价格：		电容式触摸屏贵一些，电阻式触摸屏便宜很多。

	2）思考：为什么工业应用中要用电阻式触摸屏？
		1、 消费电子产品（手机、平板电脑）用电容式触摸屏。但是在工业领域是用电阻式触摸屏，就是因为工业领域环境比较恶劣，电容式触摸屏容易受干扰，所以不合适。

		发展方向：更薄、更透明、更精准、支持点数更多。把电容触摸屏和LCD坐在一起。

	3）ft5x06数据手册浏览
		1、 软件工程师不关心触摸屏的公益，只关心软件编程接口（物理层是I2C）。

1.16.1 shell是什么鬼
	1）壳与封装
		1、 shell就是壳的意思，在计算机中经常提到shell是用户操作接口的意思。
		2、 因为计算机程序本身很复杂，里面的实现和外面的调用必须分开。接口本身就是对内部复杂的实现的一种封装，外部只需要用过接口就可以很容易的实现效果，但是却不用理会内部实现的复杂性和原理。

	2）程序或操作系统的用户接口
		1、 操作系统运行起来后都会给用户提供一个操作界面，这个操作界面就叫shell。用户可以通过shell来调用操作系统内部的复杂视线。
		2、 shell编程就是在shell层次上进行编程。譬如Linux中的脚本编程、windows中的批处理。

	3）两种shell：GUI和cmdline
		1、 GUI（图形用户界面），特点是操作简单、易学易用，适合使用电脑工作的人。
		2、 cmdline（命令行界面），譬如Linux的中断和windows的cmd，特点是不易用不易学，有点事可以进行方便的shell编程，适合开发者。

		展望：将来的shell应该是声音图像等接口的。

	4）shell的运行原理：由消息接收、解析、执行构成的死循环
		1、 主要分析命令行的shell的运行原理。
		2、 命令行shell其实就是一个死循环。这个死循环包含3个模块，这3个模块是串联的，包含：命令的接收、命令解析、命令执行。
		3、 命令行有一个标准命令集，用户在操作的时候必须知道自己想要的操作用哪个命令来实现，不能随便输入命令。如果用户输入一个不是标准命令的命令（不能识别的命令），提示用户这不是一个合法命令，然后重新回到命令行让用户输入下一个命令。
		4、 用户输入命令的界面是一个命令行，命令行的意思就是用户输入的命令是以行位单位的，更好理解的说用户输入的命令在胡勇按下回车键之后就算结束了，shell可以开始接受了。

	5）shell举例：uboot、Linux终端、windows图形界面等
		1、 常见的shell，uboot就是一个裸机程序构成的shell（后续就是完成一个裸机shell），Linux中和windows的cmd是操作系统下的命令行shell。windows图形界面、ubuntu图形界面、android的图形界面这些都是图形界面的shell。网页类型的shell。

1.16.2 shell实战1-从零写最简单的shell
	1）输入回显
		